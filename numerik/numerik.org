#+AUTHOR: Robin Heinemann
#+TITLE: Einführung in die Numerik (Potschka)

#+INCLUDE: "../header.org" :minlevel 1
#+LATEX_HEADER:	\setcounter{section}{-1}

# #+BEGIN_SRC	python
# def fib(n):
#     if n < 2:
#         return 1
#     else:
#         return fib(n - 1) + fib(n - 2)

# for n in range(10):
#     print(fib(n))
# #+END_SRC
# Andreas Potschka: INF 205, Raum 2.418
# Keine Vorlesung an Feiertagen
# - Do 25.05 (Himmelfahrt)
# - Do 15.06 (Fronleichnam)
# Webseite: [[http:]]//goo.gl/dzaGPd
# Klausurtermin: 27.07.2017 14-16 Uhr
# Zulassung: 50% der Punkte der Übungsaufgaben, einmal vorrechnen
# Übungsblatt Donnerstag, Beginn der Übungsgruppen 24.04, Abgabe im Mathematikon

# #+begin_src python :results	file :exports both
# import matplotlib, numpy
# matplotlib.use('Agg')
# import matplotlib.pyplot as plt
# fig = plt.figure(figsize=(4,2))
# x=numpy.linspace(-15,15)
# plt.plot(numpy.sin(x)/x)
# fig.tight_layout()
# plt.savefig('/tmp/test.pgf')
# #+end_src

# #+RESULTS:
# [[file:/tmp/test.png]]

* Einführung
  #+begin_ex latex
  Simulation einer Pendelbewegung \\
  Modellannahmen:
  - Masse $m$ an Stange
  - keine Reibung
  - Stange: Gewicht $0$, starr, Länge $l$
  -	Auslenkung $ϕ$
  *Erste Fehlerquelle:* Modellierungsfehler \\
  Modellgleichungen:
  \[F_T(ϕ) = - m·g \sin ϕ\]
  Konsistenzcheck:
  \begin{align*}
  F_T(0) = 0 \tag{Ruhelage} \\
  F_T(\frac{\pi}{2}) = F_G = - m g \\
  \end{align*}
  Bewegungsgleichungen:
  - Weg $s(t)$
  - $\dd{s}{t} =: v(t)$ Geschwindigkeit
  - $\dd{v}{t} =: a(t)$	Beschleunigung
  Beziehungen:
  - Bogenlänge $s(t) = l ϕ(t)$
  - 2. Newton'sches Gesetz ($F = m a$)
    \[-m g \sin ϕ(t) = m \dd{}{t} v(t) = m \frac{\d^2}{\d t^2} s(t) = m l \frac{\d^2}{\d t^2} ϕ(t)\]
  $⇒$ DGL 2. Ordnung
  \[\frac{\d^2}{\d t^2} ϕ(t) = - \frac{g}{l} \sin ϕ(t) \quad t \geq 0\]
  Für eindeutige Lösung braucht man zwei Anfangsbedingungen:
  \[ϕ(0) = ϕ_0\quad \dd{}{t}ϕ(0) = u_0\]
  Lösung bei kleiner Auslenkung: Linearisiere um $ϕ = 0$
  \begin{gather*}
  \sin ϕ = ϕ - \frac{1}{3!} ϕ^3 + \dots \approx ϕ \\
  ⇒ \frac{\d^2}{\d t^2} ϕ(t) = -\frac{g}{l}ϕ(t)
  \end{gather*}
  Für $u_0 = 0$ findet man mit dem Ansatz $ϕ(t) = A \cos(ω t)$:
  \[-ω^2 A \cos (ω t) = -\frac{g}{l} A \cos (ω t)\]
  die Lösung:
  \[ϕ(t) = ϕ_0\cos(\sqrt{\frac{g}{l}}t)\]
  Fehlerquelle: Abschneidefehler. \\
  Numerische Lösung: \\
  Setze $u(t) := \dd{}{t} ϕ(t)$
  \[\dd{}{t} \cvec{ϕ; u} = \cvec{u; - \frac{g}{l}\sin(ϕ)}\]
  Appraximation mit Differenkenquotient
  \[\cvec{u(t); -\frac{g}{l}\sin{ϕ(t)}} = \dd{}{t} \cvec{ϕ; u} = \lim_{Δt \to 0} \frac{1}{Δt}\cvec{ϕ(t + Δt) - ϕ(t); u(t + Δt) - u(t)} \approx \underarrow[\frac{1}{Δt}]{> 0, klein} \cvec{ϕ(t + Δt) - ϕ(t); u(t + Δt) - u(t)}\]
  Fehlerquelle: Diskretisierungsfehler \\
  Auf Gitter $t_n = n Δt$ mit Werten $ϕ_n = ϕ(n Δt), u_n = u(n Δt)$:
  \[ϕ_{n + 1} = ϕ_n + Δt u_n, u_{n + 1} = u_n - Δt \frac{g}{l}ϕ_n\]
  Kleinerer Diskretisierungsfehler mit zentralen Differenzen:
  \[-\frac{g}{l} \sinϕ(t) = \frac{\d^2}{\d t^2} ϕ(t) \approx \frac{ϕ(t + Δt) - 2ϕ(t) + ϕ(t - Δt)}{Δt^2}\]
  Rukursionsformel:
  \[ϕ_{n + 1} = 2ϕ_n - ϕ_{n - 1} - Δt^2 \frac{g}{l}\sin ϕ_n, n\geq 1\]
  mit $ϕ_1 = ϕ_0 + Δt n_0$ (Expliziter Euler) \\
  Letzte Fehlerquelle: Rundungsfehler
  #+end_ex
* Fehleranalyse
** Zahldarstellung und Rundungsfehler
   Anforderung: Rechnen mit reellen Zahlin auf dem Computer. \\
   Problem: Speicher endlich ($⇒$ endliche Genauigkeit). \\
   Lösung: Gleitkommazahlen, ein *Kompromiss* zwischen:
   - Umfang darstellbarer Zahlen
   - Genauigkeit
   - Geschwindigkeit einfacher Rechenoperationen (+, -, ·, /)
   Alternativen:
   - Fixkommazahlen
   - logarithmische Zahlen
   - Rationalzahlen
   #+begin_defn latex
   Eine (normalisierte) Gleitkommazahl zur Basis $b ∈ ℕ, b \geq 2$, ist eine Zahl $x ∈ ℝ$ der Form
   \[x = \pm m · b^{\pm e}\]
   mit der Mantisse $m = m_1 b^{-1} + m_2 b^{-2} + \dots ∈ ℝ$ und dem Exponenten
   $e = e_{s - 1}b^{s - 1} + \dots + e_0 b^0 ∈ ℕ$, wobei $m_i, e_i ∈ \{0, \dots, b - 1\}$.
   Für $x \neq 0$ ist die Darstellung durch die Normieungsvorschrift $m \neq 0$ eindeutig.
   Für $x = 0$ setzt man $m = 0$.
   #+end_defn
   #+ATTR_LATEX: :options [$b = 10$]
   #+begin_ex latex
   - $m_i$: $i$ -te Nachkommastelle der Mantisse
   - $e$: Verschiebt das Komma um $e$ Stellen.
   \begin{align*}
   \num{0.314e1} &= \num{3.14} \\
   \num{0.123e6} &= \num{123000}
   \end{align*}
   #+end_ex
   Auf dem Rechner stehen nur endlich viele Stellen zur Verfügung: \\
   $r$ Ziffern + 1 Vorzeichen für Mantisse $m$ \\
   $s$ Ziffern + 1 Vorzeichen für Exponenten. \\
   Für $x = \pm [m_1 b^{-1} + \dots + m_r b^{-r}] · b^{\pm[e_{s - 1} b^{s - 1} + \dots + e_0 b^0]}$
   muss man alsu nur $(\pm)[m_1\dots m_r](\pm)[e_{s - 1} \dots e_0]$
   ebspeichern. Wählt man $b = 2$, so gilt $m_i, e_i ∈ \{0, 1\}$
   und $x$ kann mit $2 + r + s$ Bits gespeichert werden (Maschinenzahlen).
   Maschinenzahlen bilden das numerische Gleitkommagitter $A = A(b, r, s)$
   #+ATTR_LATEX: :options [$b = 2, r = 3, s = 1$]
   #+begin_ex latex
   \begin{align*}
   m &= \frac{1}{2} + m_2 \frac{1}{4} + m_3 \frac{1}{8} ∈ \{\frac{4}{8}, \frac{5}{8}, \frac{6}{8}, \frac{7}{8}\} \\
   e &= e_0 ∈ \{0, 1\}
   \end{align*}
   #+end_ex
   Da $A$ endlich ist, gibt es eine größte/kleinste darstellbare Zahl:
   \begin{align*}
   x_\{min/max\} &= \pm (b - 1) [b^{-1} + \dots + b^{-r}]·b^{(b - 1)[b^{s - 1} + \dots + b^0]} \\
   &= \pm (1 - b^{-r}) · b^{(b^s - 1)}
   \end{align*}
   sowie eine kleinste positive/größte negative Zahl:
   \begin{align*}
   x_{posmin/negmax} &= \pm b^{-1} · b^{-(b - 1)[b^{s - 1} + \dots + b^0]} \\
   &= b^{-b^s}
   \end{align*}
   Das gängigste Format ist das IEEE-Format, das auch hinter dem Python-Datentyp float steht:
   \[x = \pm m · 2^{c - 1022}\]
   Dieser Datentyp ist 64 Bit (8 Byte) groß (dopplte Genauigkeit, double). Davon speichert 1 Bit das Vorzeichen, 52 Bits die Mantisse $m = 2^{-1} + m_2 2^{-2} + \dots + m_{53} 2^{-53}$
   und 11 Bits die Charakteristik $c = c_0 2^0 + \dots + c_{10} 2^{10}$, mit $m_i, c_i ∈ \{0, 1\}$.
   Es gibt folgende spezielle Werte:
   - Alle $c_i, m_i = 0: x = \pm 0$
   - Alle $m_i = 0, c_i = 1: x = \pm ∞$
   - Ein $m_i \neq 0$, alle $c_i = 1$: x = NaN (not a number)
   Für $c$ bleibt damit ein Bereich von $\{0, \dots, 2046\}$ beziehungsweise $c - 1022 ∈ \{-1022, \dots, 1024\}$.
   Damit gilt:
   - $x_{max} \approx 2^{1024} \approx \num{1.8e308}, x_{min} = -x_{max}$
   - $x_{posmin} = 2^{-1022} \approx \num{2.2e-308}, x_{negmax} = -x_{posmin}$
   Ausgangsdaten $x ∈ ℝ$ einer numerischen Aufgabe und die Zwischenergebnisse einer Rechnung müssen durch Maschinenzahlen dargestellt werden. Für Zahlen des "zulässigen" Bereichs $D = [x_{min}, x_{negmax}] ∪ \{0\} [x_{posmin}, x_{max}]$ wird
   eine Rundungsoperation $\rd: D \to A$ verwendet, die
   \[\abs{x - \rd{x}} = \min_{y ∈ A} \abs{x - y} ∀ x ∈ D\]
   erfüllt.
   #+ATTR_LATEX: :options [Natürliche Rundund im IEEE-Format]
   #+begin_ex latex
   \[\rd(x) = \sgn(x) · \begin{cases} 0, m_1, \dots, m_{53} · 2^e & m_{54} = 0 \\ \string(0, m_1, \dots, m_{53} + 2^{-53}\string) · 2^e & m_{54} = 1\end{cases}\]
   Rundungsfehler:
   - absolut:
	 \[\abs{x -  \rd(x)} \leq \frac{1}{2} b^{-r} b^e\]
   - relativ:
	 \[\abs{\frac{x - \rd(x)}{x}} \leq \frac{1}{2} \frac{b^{-r} b^e}{\abs{m} b^e} \leq \frac{1}{2} b^{-r + 1}\]
   Der relative Fehler ist für $x ∈ D \setminus \{0\}$ beschränkt durch die "Maschienengenauigkeit"
   \[eps = \frac{1}{2} b^{-r + 1}\]
   Für $x ∈ D$ ist $\rd(x) = x(1 + ε), \abs(ε) \leq eps$. Für das IEEE-Format (double)
   \[eps = \frac{1}{2} 2^{-52} \approx 10^{-16}\]
   #+end_ex
   Arithmetische Grundoperationen
   \[*: ℝ × ℝ \to ℝ, * ∈ \{x, -, +, /\}\]
   werden auf dem Rechner ersetzt durch Maschinenoperationen:
   \[\oast: A × A \to A\]
   Dies ist normalerweise für $x, y ∈ A$ und $x * y ∈ D$ realisiert durch
   \[x \oast y := \rd(x * y) = (x * y)(1 + ε), \abs{ε} \leq eps\]
   Dazu werden die Operationen maschinenintern (unter Verwendung einer längeren Mantisse) ausgeführt, normalisiet und dann gerundet. Im Fall $x * y \not ∈ D$ gibt es eine Fehlermeldung (overflow, underflow)
   oder das Ergebnis NaN.
   Achtung: Das Assoziativ- und Distributivgesetz gilt dann nur näherungsweise. Im Allgemeinen ist für $x, y, z ∈ A$
   \begin{align*}
   \string(x \oplus y\string) \oplus z &\neq x \oplus (y \oplus z) \\
   \string(x \oplus y\string) \odot z &\neq (x \odot z) \oplus (y \odot z)
   \end{align*}
   Insbesondere gilt für $\abs{y} \leq \frac{\abs{x}}{b} eps$
   \[x \oplus y = x\]
   Damit ergibt sich eine alternative Charakterisierung der Maschienengenauigkeit: $eps$ ist die kleinste positive Zahl in $A$, sodass $1 \oplus eps \neq 1$
