#+AUTHOR: Robin Heinemann
#+TITLE: Einführung in die Anwendungsorientierte Informatik (Köthe)

#+INCLUDE: "../header.org" :minlevel 1

# #+BEGIN_SRC cpp
# for(int i = 0; i < 5) {
#    std::cout << i << std::endl;
# }
# #+END_SRC

#+INCLUDE: "introduction.org" :minlevel 1
#+INCLUDE: "differences.org" :minlevel 1
#+INCLUDE: "substitution_model.org" :minlevel 1
#+INCLUDE: "machine_code.org" :minlevel 1
#+INCLUDE: "functional_programming.org" :minlevel 1
#+INCLUDE: "procedural_programming.org" :minlevel 1
#+INCLUDE: "datatypes.org" :minlevel 1
#+INCLUDE: "stack_model.org" :minlevel 1
#+INCLUDE: "references.org" :minlevel 1
#+INCLUDE: "container.org" :minlevel 1
#+INCLUDE: "itertators.org" :minlevel 1

* Insertion Sort
  Schnellster Sortieralgorithmus für kleine Arrays ($n\leq 30$) hängt von Compiler und CPU ab.
  Idee von Insertion Sort:
  - wie beim Aufnehmen und Ordnen eines Kartenblatts
  - gegeben: bereits sortierte Teilmenge bis Position $k - 1$ Karten bereits in Fächer
  - Einfügen des k-ten Elements an richtiger Stelle \rightarrow Erzeuge Lücke an richtiger Position durch verschieben von Elementen nach rechts
  - Wiederholung für $k = 1, \ldots, N$
  - Beispiel:
    | 4 | 2 | 3 | 5 | 1 |
    |---+---+---+---+---|
    | 4 | _ | 3 | 5 | 1 |
    | _ | 4 | 3 | 5 | 1 |
    | 2 | 4 | 3 | 5 | 1 |
    |---+---+---+---+---|
    | 2 | 4 | _ | 5 | 1 |
    | 2 | _ | 4 | 5 | 1 |
    | 2 | 3 | 4 | 5 | 1 |
    |---+---+---+---+---|
    | 2 | 3 | 4 | _ | 1 |
    | 2 | 3 | 4 | 5 | 1 |
    |---+---+---+---+---|
    | 2 | 3 | 4 | 5 | _ |
    | _ | 2 | 3 | 4 | 5 |
    | 1 | 2 | 3 | 4 | 5 |
  #+BEGIN_SRC cpp
  void insertion_sort(std::vector<double> & v) {
    for(int i = 0; i < v.size(); i++) {
  	  double current = v[i];
  	  int j = i; // Anfangsposition der Lücke
  	  while(j > 0) {
  		  if(v[j - 1] < current) { // -> if(cmp(a, b))
  			  break; // j ist richtige Position der Lücke
  		  }
  		  v[j] = v[j - 1];
  		  j--;
  	  }
  	  v[j] = current;
    }
  }
  #+END_SRC
  Andere Sortierung: definiere Funktor \code{cmp(a, b)}, der das gewünschte kleiner realisiert (gibt genau dann "true" zurück, wenn a "kleiner" b nach neuer Sortierung).
  Neue Sortierung am besten per Lambda-Funktion \code{an std::sort} übergeben
  #+BEGIN_SRC cpp
  std::sort(v.begin(), v.end()); // Standartsort mit "<"
  std::sort(v.begin(), v.end(), [](double a, double b) { return a < b; }); // Standardsortierung aufsteigen
  std::sort(v.begin(), v.end(), [](double a, double b) { return b < a; }); // absteigende Sortierung
  std::sort(v.begin(), v.end(), [](double a, double b) { return std::abs(a) < std::abs(b); }); // Normal nach Betrag; // Normal nach Betrag
  std::sort(v.begin(), v.end(), [](std::string a, std::string b) {
	  std::transform(a.begin(), a.end(), a.begin(), std::tolower);
	  std::transform(b.begin(), b.end(), b.begin(), std::tolower);
	  return a < b;
  });
  #+END_SRC
* generische Programmierung
  insertion_sort soll für beliebige Elementtypen funktionieren.
  #+BEGIN_SRC cpp
  template<typename T>
  void insertion_sort(std::vector<T> & v) {
	  for(int i = 0; i < v.size(); i++) {
		  T current = v[i];
		  int j = i; // Anfangsposition der Lücke
		  while(j > 0) {
			  if(v[j - 1] < current) { // -> if(cmp(a, b))
				  break; // j ist richtige Position der Lücke
			  }
			  v[j] = v[j - 1];
			  j--;
		  }
		  v[j] = current;
	  }
  }
  #+END_SRC
  Ziel: benutze template-Mechanismus, damit *eine* Implementation für viele verschiedene Typen verwendbar ist
  - erweitert funktionale und prozedurale und objekt-orientiere Programmierung
  zwei Arten von Templates ("Schablone"):
  1. Klassen-templates für Datenstrukturen, zum Beispiel Container sollen beliebige Elementtypen unterstützen
     - Implementation $\implies$ später
	 - Benutzung: Datenstrukturname gefolgt vom Elementtyp in spitzen Klammern (std::vector<double>), oder mehrere Typen, zum Beispiel Schlüssel und Wert bei std::map<std::string, double>
  2. Funktionen-Templates: es gab schon function overloading
	 #+BEGIN_SRC cpp
	 int sq(int x) {
		 return x * x;
	 }

	 double sq(double x) {
		return x * x;
	 }

	 // und so weiter für komplexe und rationale Zahlen...
	 #+END_SRC
	 Nachteil:
	 - wenn die Implementationen gleich sind \rightarrow nutzlose Arbeit
	 - Redundanz ist gefährlich: korrigiert man einen Bug wir leicht eine Variante vergessen
	 Mit templates reicht eine Implementation:
	 #+BEGIN_SRC cpp
	 template<typename T> // T: Platzhalter für beliebigen Typ, wird später durch einen tatsächlichen Typ ersetzt
	 T sq(T x) {
		 return x * x; // implizierte Anforderung an den Typ T, er muss Multiplikation unterstützen, sonst: Fehlermeldung
	 }
	 #+END_SRC
** Funktionstemplates
   Wie bei Substituieren von Variablen mit Werten, aber jetzt mit Typen.
   Benutzung:
   Typen für die Platzhalter hinter dem Funktionsnamen in spitzen Klammern
   #+BEGIN_SRC cpp
   sq<int>(2) == 4;
   sq<double>(3.0) == 9.0,
   #+END_SRC
   Meist kann man die Typenangabe <type> weglassen, weil der Computer sie anhand des Argumenttyps automatisch einsetzt:
   #+BEGIN_SRC cpp
   sq(2); // == sq<int>(2) == 4
   sq(3.0); // == sq<double>(3.0) == 9
   #+END_SRC
   Kombiniert man templates mit Overloading, wird die ausprogrammierte Variante vom Compiler bevorzugt.
   Komplizierte Fälle (Argument teilweise Template, teilweise hard_coded) $\implies$ für Fortgeschrittene. \\
   Funktion, die ein Array auf Konsole ausgibt, für beliebige Elementtypen:
   #+BEGIN_SRC cpp
   template<typename ElementType>
   void print_vector(std::vector<ElementType> const & v) {
  	 std::cout << "{";
  	 if(v.size() > 0) {
  		 std::cout << " " << v[0];
  		 for(int i = 1; i < v.size(); i++) {
  			 std::cout << ", " << v[i];
  		 }
  	 }
  	 std::cout << " }";
   }
   #+END_SRC
   Verallgemeinerung für beliebige Container mittels Iteratoren:
   #+BEGIN_SRC cpp
   std::list<int> l = {1, 2, 3};
   print_container(l.begin(), l.end()); // "{1,2,3}"
   #+END_SRC
   es genügen forward_itertators
   #+BEGIN_SRC cpp
   Iterator iter2 = iter1; // Kopie erzeugen
   iter1++; // zum nächsten Element
   iter1 == iter2; // Zeigen sie auf das selbe Element?
   iter1 != end;
   *iter1; // Zugriff auf aktuelles Element

   template<typename Iterator>
   void print_container(Iterator begin, Iterator end) {
  	   std::cout << "{}";
  	   if(begin != end) { // Container nicht leer?
  		   std::cout << " " << *begin++;
  		   for(;begin != end; begin++) {
  			   std::cout << ", " << *begin;
  		   }
  	   std::cout << "}";
   }
   #+END_SRC
   Überprüfen, ob Container sortiert ist:
   #+BEGIN_SRC cpp
   template<typename E, typename CMP>
   bool check_sorted(std::vector<E> const & v, CMP less_than) {
  	   for(int i = 1; i < v.size(); i++) {
  		    if(less_than(v[k], v[k - 1])) { // statt v[k] < v[k - 1], ausnutzen der Transitivität
  			   return false;
  		   }
  	   }
  	   return true;
   }

   // Aufruf:
   std::vector<double> v = {1.0, 2.0, 3.0};
   check_sorted(v, [](double a, double b) { return a < b; } ); // == true

   check_sorted(v, [](double a, double b) { return a > b; } ); // == false

   // Implementation für Iteratoren
   template<typename Iterator, typename CMP>
   bool check_sorted(Iterator begin, Iterator end, CMP less_than) {
  	   if(begin == end) {
  		   return true;
  	   }
  	   Iterator next = begin;
  	   ++next;
  	   for(; next != end; ++begin, ++next) {
  		   if(less_than(*next, *begin)) {
  			   return false;
  		   }
  	   }
  	   return true;
   }
   // == std::is_sorted
   #+END_SRC
   Bemerkung: Compiler-Fehlermeldungen bei Template-Code sind oft schwer zu interpretieren, $\implies$ Erfahrung nötig aber: Compiler werden darin immer besser, besonders clang-Compiler.
   Mit Templates kann man noch viel raffinierter Dinge machen, zum Beispiel Traits-Klassen, intelligent libraries template meta programming $\implies$ nur für Fortgeschrittene.
* Effizienz von Algorithmen und Datenstrukturen
** Bestimmung der Effizienz
   2 Möglichkeiten:
   1. Messe die "wall clock time" - wie lange muss man auf das Ergebnis warten
   2. unabhängig von Hardware benutzt man das Konzept der algorithmischen Komplexität
*** wall clock
   wall clock time misst man zum Beispiel mit dem Modul <chrono>
   #+BEGIN_SRC cpp
   #include <chrono>
   #include <iostream>

   int main() {
	   // alles zur Zeitmessung vorbereiten

	   auto start = std::chrono::high_resolution_clock::now(); // Startzeit
	   // code der gemessen werden soll
	   auto stop = std::chrono::high_resolution_clock::now();
	   std::chrono::duration<double> diff = stop - start; // Zeitdifferenz
	   std::cout << "Zeitdauer: " << diff.count() << " Sekunden\n" << std::endl; // ausgeben
   }
   #+END_SRC
   Pitfalls:
   - moderne Compiler optimieren oft zu gut, das heißt komplexe Berechnungen werden zur Compilezeit ausgeführt und ersetzt $\implies$ gemessene Zeit ist viel zu kurz.
	 Abhilfen:
	 - Daten nicht "hard-wired", sondern zum Beispiel von Platte lesen
	 - "volatile" Schlüsselwort "volatile int k = 3;"
   - der Algorithmus ist schneller als die clock $\implies$ rufe den Algorithmus mehrmals in einer Schleife
	 auf
   - die Ausführung ihres Programms kann vom Betriebssystem jederzeit für etwas wichtigeres unterbrochen werden
	 (zum Beispiel Mail checken) $\implies$ gemessene Zeit zu lang $\implies$ messe
	 mehrmals und nimm die kürzeste Zeit (meist reicht 3 bis 10 fach)
   - Faustregel: Messung zwischen $\SI{0.02}{\second}$ und $\SI{3}{\second}$
   Nachteil: Zeit hängt von der Qualität der Implementation, den Daten (insbesondere der Menge) und der Hardware ab
*** algorithmische Komplexität
	Algorithmische Komplexität ist davon unabhängig, ist eine Art theoretisches Effizienzmaß. Sie
	beschreibt, wie sich die Laufzeit verlängert, wenn man mehr Daten hat.

	#+begin_ex latex
	Algorithmus braucht für $n$ Elemente $x$ Sekunden, wie lange dauert es für $2n$, $10n$ für große $n$
	#+end_ex
	Bei effiziente Algorithmen steigt der Aufwand mit $n$ nur langsam (oder bestenfalls gar nicht) \\
	Grundidee:
	1. berechne, wie viele elementare Schritte der Algorithmus in Abhängigkeit von $n$ benötigt $\implies$ komplizierte Formel $f(n)$
	2. vereinfache $f(n)$ in eine einfache Formel $g(n)$, die dasselbe wesentliche Verhalten hat. Die Vereinfachung erfolgt mittels *$O$ -Notation* und ihren Verwandten
	   Gegeben: $f(n)$ und $g(n)$
	   1. $g(n)$ ist eine asymptotische (für große $n$) obere Schranke für $f(n)$ ("f(n) \leq g(n)"), $f(n) \in \mathcal{O}(g(n))$ "$f(n)$ ist in der Komplexitätsklasse $g(n)$", wenn es ein $n_0$ (Mindestgröße) gibt
		  und $C$ (Konstante) gibt, sodass $\Forall n > n_0: f(n) \leq C g(n) \iff f(n) \in \mathcal{O}(g(n))$
	   2. $g(n)$ ist asymptotische untere Schranke für $f(n)$ ($f(n) \geq g(n)$)
		  \[f(n) \in \Omega(g(n)) \iff \Exists n_0,C : \Forall n > n_0 f(n) \geq C g(n)\]
	   3. $g(n)$ ist asymptotisch scharfe Schranke für $f(n) (f(n) = g(n))$
		  \[f(n) \in \Theta(g(n)) \iff f(n) \in \mathcal{O}(g(n)) \wedge f(n) \in \Omega(g(n))\]
	Regeln:
	1. $f(n) \in \Theta(f(n)) \implies f(n) \in \mathcal{O}(f(n)), f(n) \in \Omega(f(n))$
	2. $c' f(n) \in \Theta(f(n))$
	3. $\mathcal{O}(f(n)) \cdot \mathcal{O}(g(n)) \in \mathcal{O}(f(n) g(n))$ \hfill Multiplikationsregel
	4. $\mathcal{O}(f(n)) + \mathcal{O}(g(n)) \in \mathcal{O}(\text{"`max"'}(f(n), g(n)))$ \hfill Additionsregel \\
	   formal: wenn $f(n) \in \mathcal{O}(g(n)) \implies \mathcal{O}(f(n)) + \mathcal{O}(g(n)) \in \mathcal{O}(g(n))$ \\
	   $g(n) \in \mathcal{O}(f(n)) \implies \mathcal{O}(f(n)) + \mathcal{O}(g(n)) \in \mathcal{O}(f(n))$
	5. $n^p \in \mathcal{O}(n^q)$ wenn $p \leq q$
	Beliebte Wahl für $g(n)$
	- $\mathcal{O}(1)$ \hfill "konstante Komplexität" \\
	  elementare Operation "+, -, *, /", Array-Zugriff v[k] (v: std::vector)
	- $\mathcal{O}(\log(n))$ \hfill "logarithmische Komplexität" \\
	  zum Beispiel: auf Element von std::map zugreifen m[k] (m: std::map)
	- $\mathcal{O}(n)$ \hfill "lineare Komplexität" \\
	  zum Beispiel std::transform() ($n$ = Anzahl der transformierten Elemente)
	- $\mathcal{O}(n \log(n))$ \hfill{"`n log n"', "`log linear"' "`linearithmisch"'} \\
	  Beispiel: std::sort
	- $\mathcal{O}(n^2)$ \hfill "quadratische Komplexität"
	- $\mathcal{O}(n^p)$ \hfill "polynomielle Komplexität"
	- $\mathcal{O}(2^n)$ \hfill "exponentielle Komplexität"
	#+begin_ex latex
	\[f(n) = 1 + 15 n + 4n^2 + 7n^3 \in \mathcal{O}(n^3)\]
	#+end_ex
*** Anwendung
	1. Fibonacci-Zahlen: $f_k = f_{k - 2} + f_{k - 1}$
	   | k     | 0 | 1 | 2 | 3 | 4 | 5 | 6 |  7 |  8 |
	   |-------+---+---+---+---+---+---+---+----+----|
	   | $f_k$ | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 |
	   #+begin_src cpp
	   int fib1(int k) {
		   if(k < 2) { // \mathcal{O}(1)
			   return k; // \mathcal{O}(1)
		   }
		   // \mathcal{O}(1)
		   int f1 = 0; // letzten beiden Fibonacci Zahlen, anfangs die ersten beiden
		   int f2 = 1;
		   for(int i = 2; i <= k; i++) { // f(k) = k - 1 e \mathcal{O}(k)
			   int f = f1 + f2; // \mathcal{O}(1)
			   f1 = f2; // \mathcal{O}(1)
			   f2 = f; // \mathcal{O}(1)
		   } // gesamte Schleife: \mathcal{O}(1)*\mathcal{O}(k) = \mathcal{O}(k)
		   return f2;
	   } // gesamte Funktion: teuerstes gewinnt: \mathcal{O}(k)

	   // rekursive Variante:
	   int fib2(int k) {
		   if(k < 2) { // \mathcal{O}(1)
			   return k; // \mathcal{O}(1)
		   }
		   return fib2(k - 2) + fib2(k - 1);
	   }
	   #+end_src
	   - sehr ineffizient, weil alle Fibonacci-Zahlen $< k$  mehrmals berechnet werden
	   Sei $f(k)$  die Anzahl der Schritte, $f'(k)$ die Schritte oberhalb, Annahme: jeder Knoten ist $\mathcal{O}(1) \implies f(k) \in \mathcal{O}(\text{Anzahl Knoten})$.
	   Oberhalb ist der Baum vollständig (jeder innere Knoten hat zwei Kinder), Anzahl der Knoten im vollständigen Baum der Tiefe $l$:
	   \[1 + 2 + 4 + \ldots + 2^l = 2^{l + 1} - 1\]
* Zahlendarstellung im Computer
  Problem: es gibt $\infty$ viele Zahlen, aber der Computer ist endlich.
** Natürliche Zahlen
   Natürliche Zahlen $\implies x \geq 0$. c++ bietet Typen verschiedene Größe.
   | klassisch          | mit Größe | Anzahl Bits | Bereich                | Literale |
   |--------------------+-----------+-------------+------------------------+----------|
   | unsigned char      | uint8_t   | ($\geq$) 8  | 0 - 255                |          |
   | unsigned short     | uint16_t  | ($\geq$) 16 | 0 - 65535              |          |
   | unsigned int       | uint32_t  | ($\geq$) 32 | 0 - $\SI{4e9}{}$       |          |
   | unsigned long      |           | 32 oder 64  |                        |          |
   | unsigned long long | uint64_t  | 64          | 0 - 0 -  $\SI{2e19}{}$ | L        |
   was passiert bei zu großen Zahlen? \\
   - alle Operationen werden Modula $2^m$ ausgeführt, wenn der Typ $m$ Bits hat
	 #+begin_src cpp
	 uint8_t x = 250, y = 100;
	 uint8_t s = x + y; // 350 % 256 = 94
	 uint8_t p = x * y; // 25000 % 256 = 168
	 #+end_src
   "integer overflow": einfach Bits oberhalb von $m$ wegwerfen
*** Pitfalls
	#+begin_src cpp
	std::vector<uint8_t> v = { ... };
	uint8_t sum = 0; // FALSCH, da es zu overflow kommen kann
	// verwende uint32_t, uint64_t, verhindern overflow mit hoher Wahrscheinlichkeit
	for(int k = 0; k < v.size(); k++) {
		sum += v[k];
	}

	// Endlosschleife, da i nie < 0, da unsigned
	// Abhilfe: int verwenden
	for(uint8_t i = v.size(); i >= 0; i++) {
		// auf v[k] zugreifen
	}
	#+end_src
*** arithmetische Operationen
	- Addition in Kapitel Automaten \\
**** Subtraktion
	 Subtraktion kann auf Addition zurückgeführt werden
	 Erinnerung: Restklassenarithmetik: (Modulo) \\
	 alle Zahlen mit dem gleichen Rest modulo $k$ bilden "Äquivalenzklasse", zum Beispiel $k = 4$
	 \begin{align*}
	 0 \mod 4 &= 0 \equiv 4 \mod 4 \equiv 8 \mod 4 \equiv 12 \mod 4 \ldots \\
	 1 \mod 4 &= 1 \equiv 5 \mod 4 \equiv 9 \mod 4 \equiv 13 \mod 4 \ldots \\
	 2 \mod 4 &= 2 \equiv 6 \mod 4 \equiv 10 \mod 4 \equiv 14 \mod 4 \ldots \\
	 3 \mod 4 &= 3 \equiv 7 \mod 4 \equiv 11 \mod 4 \equiv 15 \mod 4 \ldots \\
	 \end{align*}
	 Ein Mitglied jeder Äquivalenzklasse wird Repräsentant. \\
	 Hier: kleinste Repräsentanten $0, \ldots, (k - 1)$, mit $k = 2^m$
	 sind das gerade die uint-Werte \\
	 Eigenschaft: man kann Vielfache $n k$ addieren, ohne Äquivalenzklasse zu ändern: \\
	 \[ (a - b) \mod 2^m = (a + \underbrace{2^m - b}_{\mathclap{z:~\text{Zweierkomplement}}}) \mod 2^m = (a + z) \mod 2^m \]
	 $z = (2^m - b) \mod 2^m$ lässt sich billig berechnen als $(\sim b + 1) \mod 2^m$
	 Dabei ist $\sim$ bitweise Negation (dreht alle Bits um)
	 - $m = 4, \sim(1001) = 0110$
	 #+begin_thm latex
	 \[(2^m - b) \mod 2^m = (\sim b + 1) \mod 2^m\]
	 #+end_thm
	 #+begin_proof latex
	 \begin{align*}
	 b + \sim b &= 1111\ldots 1 = 2^m - 1 \\
	 \sim b + 1 &= 2^{m} - b \\
	 \intertext{Fall 1: $b > 0$}
	 \implies \sim b &< 2^m - 1 \implies \sim b + 1 < 2^m \implies (\sim b + 1) \mod 2^m = \sim b + 1 \\
	 \implies (\sim b + 1) \mod 2^m &= (2^m - b) \mod 2^m \\
	 \intertext{Fall 2: $b = 0$}
	 \implies \sim b &= 2^m - 1 \\
	 \sim b + 1 &= 2^m \\
	 \ (\sim b + 1) \mod 2^m &= 0 \\
	 2^m - b &= 2^m \\
	 z &= (2^m - b) \mod 2^m = (\sim b + 1) \mod 2^m = 0
	 \end{align*}
	 #+end_proof
**** Multiplikation
	 Neue Operationen: $\ll$  und $\gg$ (left und right shift). Verschiebt die Bits um $k$ Positionen nach
	 links oder rechts. Die herausgeschobenen Bits werden vergessen und auf der anderen Seite durch
	 $0$ -Bits ersetzt.

	 #+begin_src cpp
	 // m = 8
	 assert(11011101b << 3 == 11101000b)
	 assert(11011101b >> 3 == 00011011b)
	 #+end_src
	 #+begin_thm latex
	 \begin{align*}
	 x \ll k \equiv (x \cdot 2^k) \mod 2^m \\
	 x >> k \equiv (\frac{x}{2^k}) \\
	 \end{align*}
	 #+end_thm
	 Operation \amp und |: bitw4eise und beziehungsweise oder-Verknüpfung (nicht verwechseln mit \amp\amp und || für logische Operationen)
	 m = 8: \\
	 $10110011 \amp 1 = $
	 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
	 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
	 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
	 (testet, ob in linker Zahl Bit 0 gesetzt ist) \\
	 $10110011 \mid 1 =$
	 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
	 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
	 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
	 kombiniere \amp mit $\ll$:
	 \[x \& (1 \ll k)\]
	 testet, ob in $x$ Bit $k$ gesetzt ist.
	 #+begin_src cpp
	 uint8_t mul(uint8_t x, uint8_t y) {
		  uint8_t res = 0;
		  for(int i = 0; i < 8; i++) {
			   if(y & (1 << i)) {
					res += x;
			   }
			   x = x << 1; // x * 2
		  }
	 }
	 #+end_src
** Ganze Zahlen
   | klassisch        | mit Größe | Anzahl Bits | Bereich               |
   |------------------+-----------+-------------+-----------------------|
   | signed char      | int8_t    |           8 | -128 \ldots 127       |
   | signed short     | int16_t   |          16 | -2^15 \ldots 2^15 - 1 |
   | signed int       | int32_t   |          32 | -2^31 \ldots 2^31 - 2 |
   | signed long      |           |  32 oder 64 |                       |
   | signed long long | int64_t   |          64 | -2^63 \ldots 2^63 - 1 |
   Wird der erlaubte Bereich überschritten, ist Verhalten Compiler abhängig.
   In der Praxis: auch Modulo $2^m$, aber mit anderen Repräsentanten.


   für Restklassen: \\
   statt $0\ldots 2^m$ bei unsigned jetzt $-2^{m - 1} \ldots 2^{m - 2} - 1$ \\
   das heißt:
   - $x < 2^{m - 1}$: Repräsentant bleibt
   - $x \geq 2^{m - 1}$: neuer Repräsentant $x - 2^{m}$ ist gleiche Restklasse
   Vorteil: $x, -, *$ kann von unsigned übernommen werden \\
   $a,b$ signed: $a$ OP $b$ \to $c$ signed
   (interpretiere Bitmuster von $a$ und $b$ als unsigned und Interpretiere das Ergebnis dann als signed)
  Konsequenzen:
   - bei negativer Zahl ist höchstes Bit 1, weil $x \to x - 2^m$ falls $x \geq 2^{m - 1}$
   - unäre Negation $-x$ durch Zweierkomplement
	 \begin{align*}
	 -x &= (\sim x + 1) \mod 2^m \\
	 -0 &= (\sim 00000000 + 1) \mod 2^8 \\
	 &= (11111111 + 1) \mod 2^8 \\
	 &= \underbrace{(100000000)}_{2^8} \mod 2^8 = 0
	 -1 &= (\sim 00000001 + 1) \mod 2^8 \\
	 &= (11111110 + 1) \mod 2^8 \\
	 &= \underbrace{(11111111)}_{2^8 - 1 < 2^8} \mod 2^8 \\
	 &= 11111111
	 \end{align*}
   Ausnahmeregel für $\gg$ bei negativen Zahlen: Compilerabhängig, meist wird links
   ein 1-Bit reingeschoben, damit Zahl negativ bleibt $\implies$ es gilt immer noch $x \gg k = (x / 2^k)$
   Reichen 64 Bit nicht aus (zum Beispiel bei moderner Verschlüsselung) verwende BigInt: Datentyp variabler Größe.
   Zum Beispiel GNU Multi-Precision Library
** reelle Zahlen
   c++ bietet Typen
   | Name        | Größe                          | Bereich                        | kleinste Zahl   | Literale  |
   |-------------+--------------------------------+--------------------------------+-----------------+-----------|
   | float       | 32bit                          | $\SI{-1e38}{} - \SI{1e38}{}$   | $10e-38$        | 4.0f      |
   | double      | 64bit                          | $\SI{-1e308}{} - \SI{1e308}{}$ | $\SI{1e-308}{}$ | 4.0, 1e-2 |
   | long double | platformabhängig, $\geq$ 64bit |                                |                 |           |
   Der c++ Standard legt die Größe nicht fest, aber praktisch alle gängigen CPUs benutzen Standard IEEE 754, c++
   übernimmt HW-Implementation. Ziele der Definition von reellwertigen Typen:
   - hohe Genauigkeit (viele gültige Nachkommastellen)
   - Zahlen sehr unterschiedlicher Größenskalen (zum Beispiel Durchmesser eines Proton $=\SI{2e-15}{\meter}$ vs. Durchmesser des sichtbaren Universum $\SI{1e27}{\meter}$)
	 mit natürlichen Zahlen bräuchte man $> 150$ bit
   elegante Lösung: halb-logarithmische Darstellung ("floating point"). Datentyp ist aus 3 natürlichen Zahlen zusammengesetzt (aber alles von der CPU gekapselt)
   - $S$ (1-bit): Vorzeichen, 0 = "$+$", 1 = "-"
   - $M$ (m-bit): Mantisse: Nachkommastellen
   - $E$: (e-bit, Bias b): Exponent: Größenordnung
   die eigentliche Zahl wird durch
   \[x = (-1)^s \cdot (1 + M\cdot 2^{-m}) \cdot 2^{E-b}\]
   - $M\cdot 2^{-m} \in [0, \frac{2^m - 1}{2^m}\string) \in [0,1\string)$
   - $M \in [0, 2^m - 1]$
   - $1 + M\cdot 2^{-m} \in [1,2\string)$
   Beispiel: natürliche Zahlen
   | $x$ | $M\cdot 2^{-m}$ | $E - b$ | effektive Darstellung |
   |-----+-----------------+---------+-----------------------|
   |   1 |               0 |       0 | $1\cdot 2^0$          |
   |   2 |               0 |       1 | $1\cdot 2^1$          |
   |   3 |             0.5 |       1 | $1.5\cdot 2^1$        |
   |   4 |               0 |       2 | $1\cdot 2^2$          |
   |   5 |            0.25 |       2 | $1.25\cdot 2^2$       |
   Konsequenz: alle ganzen Zahlen zwischen $-2^m, \ldots, 2^m$ könne exakt dargestellt werden und haben exakte Arithmetik. (IEEE 754)
   Werte für $m,e,b$
   - float
	 - $m = 23$
	 - $e = 8$
	 - $b = 127$
	 - $2^{E - b} \in [2^{-126}, 2^{127}] \approx [10^{-38}, 10^{38}]$
   - double
	 - $m = 52$
	 - $e = 11$
	 - $b = 1024$
	 - $2^{E - b} \in [2^{-1022}, 2^{1023}] \approx [10^{-308}, 10^{308}]$
   Anzahl der Nachkommastellen: $\eps = 2^{-m}$ (machine epsilon, unit last place (ULP))
   - float $2^{-23} \approx \SI{1e-7}{}$
   - double $2^{-52} \approx \SI{1e-16}{}$
   $\eps$ ist die kleinste Zahl, sodass
   \[(1.0 + \eps) \neq 1.0\]
   weil Nachkommastellen außerhalb der Mantisse (rechts von $2^{-m}$) ignoriert werden. $\implies$ Problem der Auslöschung von signifikanten Stellen. Wenn man zwei
   fast gleich große Zahlen subtrahiert, löschen sich fast alle Bits der Mantisse $\implies$ nur wenige gültige Nachkommastellen überleben. Zum Beispiel:
   \[0.1234567 - 0.1234566 = 0.000001 \text{( nur eine gültige Nachkommastelle!)}\]
   \[1.0 - \cos{x}, x \to 0, x\approx 0 \implies \cos{x} \approx 1 \text{ $\implies$ Auslösung}\]
   | x            | Anzahl der gültigen Stellen | Additionstheorem $1 - \cos(x) = 2(\sin(x / 2))^2$ |
   |--------------+-----------------------------+----------------------------------------------------|
   | \SI{0.001}{} | 9                           |                                                 15 |
   | \SI{1e-8}{}  | 0 (\cos(\SI{1e-8}{}))       |                                                 15 |
   Quadratische Gleichung:
   \[a x^2 + b x + c = 0, b > 0\]
   \[x_1 = \frac{1}{2 a}(-b + sqrt{b^2 - 4ac})\]
   falls $a\cdot c\wedge b^2 \gg 4ac \implies \sqrt{b^2 -4ac} \approx b \implies x_1 \approx -b + b + (\eps') \approx 0 \implies$ Auslöschung, wenig gültige Stellen. Also umstellen:
   \begin{align*}
   x_1 %= \frac{1}{2a}(-b + \sqrt{b^2 - 4ac}) \frac{-b - \sqrt{b^2 - 4ac}}{-b - \sqrt{b^2 - 4ac}} \\
   &= \frac{1}{2a} \frac{b^2 - (b^2 - 4ac)}{-b - sqrt{b^2 - 4ac}} \\
   &= \frac{2c}{\underbrace{-b -\underbrace{\sqrt{b^2 - 4ac}}_{\approx b}}_{\approx -2b}}
   \intertext{$\implies$ keine Auslöschung}
   \intertext{Dies tritt auch bei Aufgabe 8.3 der Übungszettel auf}
   \end{align*}
   Ausnahmeregeln (spezielle Werte)
   - normal: $E\in [1,2^e - 2]$
   - $E = 2^e - 1$ (größtmöglicher Wert): $\begin{cases} x = -\infty & M = 0 \wedge S = 1 \\ x = \infty & M = 0 \wedge S = 0 \\ x = ~\text{NaN}~ & M = 0\end{cases}$
	 - $\pm\infty: \frac{1.0}{0.0}, \frac{-1.0}{0.0}, \ldots$
	 - NaN: $\frac{0.0}{0.0}, \sqrt{-1.0}, \infty\cdot 0$
   - $E = 0$ (kleinstmöglicher Wert): $\begin{cases} -0 & M = 0 \wedge S = 1 \\ 0 & M = 0 \wedge S = 0 \\ \text{denormalisierte Zahlen (für sehr kleine Werte)} & M > 0 \end{cases}$
* Buchstabenzeichen
  Buchstabenzeichen: "glyphs" müssen durch Zahlen repräsentiert werden "Zeichencode"
** Geschichte
   #+ATTR_LATEX: :environment longtable :align l|l|p{2.5cm}|p{7cm}
   | 1963                | ASCII   | 7-bit                                  | Zeichen der englischen Schreibmaschine (*keine* Umlaute)                                                                                                                                                                                                                                      |
   | 1964 $\ldots$ 2000  |         | 8-bit Codes                            | mit Umlauten, Akzenten, kyrillische Zeichen, aber 8-bit sind zu wenig, um alles abzudecken $\implies$ viele verschiedene 8-bit Codes: DOS Codepage 437, Codepage 850 (Konsole im deutschen Windows), Windows-1252 ("ANSI") $\approx$ ISO 8859-1 \approx ISO 8859.15 (Westeuropäische Sprachen) |
   | 1991 $\ldots$ heute | Unicode | anfangs 16-bit, jetzt $\approx$ 21-bit | alles (chinesisch, Hieroglyphen, Emojis, $\ldots$)                                                                                                                                                                                                                                              |
   3 Codierungen für Unicode:
   - UTF-8: variable length code: pro glyph $1 \ldots 4$ uint8
   - UTF-16: variable length code: pro glyph $1 \ldots 2$ uint16
   - UTF-32: fixed length code: pro glyph 1 uint32 pro glyph
   In c++:
   - char: 8-bit Codes
   - wchar_t: 16-bit (Windows), 32-bit (Linux)
   - u16char_t, u32char_t:
   leider sehr Platformabhängig
   | Symbol | DOS | ANSI | UTF-8       |
   |--------+-----+------+-------------|
   | ö      | 148 |  246 | 195 182     |
   | €      | 221 |  128 | 226 130 172 |
   $\implies$ ICU Library. \\
   hat man alle Zeichen korrekt, ist Problem noch nicht gelöst: alphabetische Sortierung:
   - Kontext abhängig
   - sprach abhängig
   - $ä$:
	 - deutschen Wörterbuch: wie a
	 - deutsches Telefonbuch: wie ae
	 - schwedisch: hinter Zeichen $\overset{\scriptstyle \circ}{a}$
   #+BEGIN_SRC cpp
   #include <locale>
   #include <codecvt
   std::sort(v.begin(), v.end(), std::locale("se_SE.UTF-8")); // für schwedisch (falls se_SE.UTF-8 installiert)
   #+END_SRC
* Eigene Datentypen
  3 Möglichkeiten
  - enum: Aufzählungstypen $\implies$ Selbststudium
  - struct: strukturierte Daten, zusammengesetzte Typen
  - class: wie struct, auf objekt-orientiert
  struct und enum schon in C, struct und class fast gleich
  #+BEGIN_SRC cpp
  struct TypeName { // Neuer Typ
	  type_name1 var_name1; // existierende Typen
	  type_name2 var_name2;
	  // ...
  }; // Semikolon WICHTIG, falls vergessen: Fehlermeldung

  // Beispiel:
  struct Date {
	  // Datenmember, Membervariables
	  int day;
	  int month;
	  int year;
  };

  Date easter(int year) {
	  // Datum ausrechnen

	  // Datum zurückgeben
	  Date d;
	  d.day = day; // Punktsyntax kennen wir schon
	  d.month = month;
	  d.year = year;
	  return d;
  }

  struct Character {
  wchar_t clear;
  wchar_t encrypted;
  int count;
  };

  Character c;
  c.count = 0;
  c.count += 1;
  #+END_SRC
* Objektorientierte Programmierung
  Eigene Datentypen mit Kapselung. Eigene Datentypen sind zusammengesetzt aus
  einfachen existierenden Datentypen (Ausnahme: enum), zwei Arten:
  - offene Typen: Benutzer kann auf interne Daten zugreifen, "C-style types"
	wenige Beispiele in der Standardbibliothek:
	- std::pair
	- std::tm (von C übernommen)
	- std::div_t (Resultat von div(), zwei Returnwerte: Quotient und Rest)
  - gekapselte Typen: Benutzer kann nicht auf interne Daten zugreifen "private".
	Alle Benutzerzugriffe über öffentliches Interface "public". Vorteile:
	- komplexe Details zur Verwaltung bleiben verborgen
	- öffentliches Interface (hoffentlich) einfach, zum Beispiel std::vector
	- interne Details können bei Bedarf geändert werden, ohne dass sich das öffentliche Interface ändert
	  $\implies$ Benutzer muss Code nicht andern, aber plötzlich geht Programm schneller, "Rückwärts-Kompatibilität"
  Wie erreicht man Kapselung? \\
  Zwei Schlüsselwörter für eigene Typen "class" (Konvention OOP), "struct" (von C übernommen) \\
  Zwei Schlüsselwörter für Kapselung: "public" (öffentlicher Teil), "private" (gekapselter Teil). class ist
  standardmäßig "private", struct standardmäßig "public"
  #+BEGIN_SRC cpp
  class MyType {
	  // private by default
	  public:
	  // jetzt öffentlich
	  private:
	  // wieder private
	  public:
	  // etc.
  }; // <--- Semikolon wichtig
  struct MyType {
	  // öffentlich by default
	  private:
	  // jetzt privat
	  public:
	  // etc
  };
  #+END_SRC
  Benutzer können nur auf Funktionalität in public-Teil zugreifen. \\
  Die im zusammengesetzten Typ enthaltenen Daten heißen "Daten-Members", "member variables" sind
  normalerweise "private" $\implies$
  - kann nachträglich geändert werden, zum Beispiel complex real/imaginär vs. Betrag/Phase
  - Benutzer kann nicht unbeabsichtigt die Konsistenz verletzen (zum Beispiel versehentlich negativer Betrag bei complex)
  Running example: Punkt-Klasse für 2-dimensionalen Punkt
  #+BEGIN_SRC cpp
  class Point {
	  double x_; // Koordinaten als private
	  double y_; // Datenmember (Konvention "_" am Ende)
  };
  #+END_SRC
  dieser Typ ist unbenutzbar, weil alle privat. \\
  unverzichtbar: öffentliche Funktion zum Initialisieren des Speichers = "Konstruktoren"
  - Prozeduren innerhalb der Klasse, Name gleich Klassenamen, Returntyp muss weggelassen werden (fügt Compiler automatisch ein) $\implies$ nur Seiteneffekt:
	neues Objekt initialisieren, also die Konstruktoren der Datenmember aufrufen.
  - zur Erinnerung: zwei Möglichkeiten für normale Variableninitialisierung
	#+BEGIN_SRC cpp
	double z = 1.0;
	double z(1.0); // nur diese Syntax im Konstruktor erlaubt.
	double z{1,0}; // seit c++11

	class Point {
		double x_;
		double y_;
	public:
		Point(double x, double y) :x_(x), // Member x_ auf Initialwert x vom Prozedurargument setzen
		y_(y) // Member y_ auf Initialwert y vom Prozedurargument setzen
		{
		// normaler Rumpf der Prozedur, hier leer, weil nichts zu tun
		// Datenmember hier schon fertig initialisiert und können benutzt werden
		}
	};
	Point p(1.0, 2.0);
	Point q = {3.0, 4.0}
	#+END_SRC
	Spezieller Konstruktor: ohne Argument = Standardkonstruktor, "default constructor", initialisiert Objekt in Standardzustand. Zum Beispiel bei Zahlen auf 0 setzten, hier au Koordinatenursprung Point origin; $\iff$ Point origin(0.0, 0.0);
	#+BEGIN_SRC cpp
	class Point {
	// ... wie zuvor
	Point() : x_(0.0), y_(0.0) {} // Standardkonstruktor
	};
	#+END_SRC
  um mit Punkt-Objekten zu arbeiten, brauchen wir weitere Funktionen: zwei Möglichkeiten
  - Member-Funktionen: innerhalb der Klasse definiert (wie Konstruktor), dürfen auf alles private zugreifen, können als private oder public definiert sein
  - freie Funktionen: normale Funktionen außerhalb der Klasse, die ein Argument des neuen Typs haben, können nur auf Öffentliches Interface zugreifen
  wichtigste Vertreter der Member-Funktionen: Zugriffsfunktionen "Getter": erlauben Benutzer, aktuellen Zustand abzufragen:
  #+BEGIN_SRC cpp
  std::vector<int> v = {1, 2, 3};
  v.size(); // getter für Arraygröße
  Point p(1,0, 2.0);
  p.x() // -> 1.0 x-Koordinate abfragen
  p.y() // -> 2.0 y-Koordinate abfragen
  #+END_SRC
  Member-Funktionen werden mit Punkt-Syntax aufgerufen: p.x(), das Objekt for dem Punkt ist das "nullte" Argument der Funktion, Compiler macht daraus x(p).
  Bei Implementation der Member Funktion schreibt man das nullte Argument nicht hin. Der Compiler stellt es automatisch unter dem Namen "(*this)" zur Verfügung.
  #+BEGIN_SRC cpp
  class Point {
	  // ... wie zuvor
	  double x() const {
		  return (*this).x_;
	  }

	  double y() const {
		  return (*this).y_;
	  }
  };
  #+END_SRC
  Meist kann man (*this) weglassen, wenn eindeutig ist, welchen Member man meint, fügt es der Compiler es automatisch ein.
  Getter-Funktionen sind read-only (ändern die Member-Variablen nicht), man sollte sie deshalb mittels "const" explizit als read-only markieren.
  Vorteile:
  - Programmierer kann Member-Variablen nicht irrtümlich ändern
  - Funktion kann in Kontexten benutzt werden, wo das Objekt (nulltes Argument) explizit als read-only markiert ist.
	#+BEGIN_SRC cpp
	Point const cp(1.0, 2.0); // write-once
	cp.x();
	#+END_SRC
  Point auf Konsole ausgeben: nach String wandeln und String ausgeben
  - zwei Möglichkeiten:
  #+BEGIN_SRC cpp
  // Member Funktion:
  std::cout << p.to_string() << endl;
  class Point {
	  // ... wie zuvor
	  std::string to_string() const {
		  std::string res;
		  res += "[" + std::to_string((*this).x()) + "," + std::to_string((*this).y()) + "]"
		  return res;
	  }
  };

  // freie Funktion:
  std::cout << to_string(p) << endl;
  std::string to_string(Point p) const {
	  std::string res;
	  res += "[" + std::to_string((*this).x()) + "," + std::to_string((*this).y()) + "]"
	  return res;
  }
  #+END_SRC
  Was man wählt ist Geschmackssache (freie Funktion ist kompatibel zu std::to_string, kleiner Vorteil). \\
  Punkte vergleichen:
  #+BEGIN_SRC cpp
  class Point {
	  // ... wie zuvor
	  bool equals(Point other) const {
		  return (*this).x() == other.x() && (*this).y() == other.y();
	  }
	  bool operator==(Point other) const {
		  return (*this).x() == other.x() && (*this).y() == other.y();
	  }
	  bool operator!=(Point other) const {
		  return (*this).x() != other.x() || (*this).y() != other.y();
	  }
  }

  Point p(1.0, 2.0);
  Point origin;
  assert(p.equals(p));
  assert(!p.equals(origin));
  // üblicher: Infix-Notation
  assert(p == p);
  assert(!(p == origin));
  assert(p != origin);
  #+END_SRC
  Für Infix-Notation muss Präfix-Variante operator== und operator!= implementiert werden.
  #+BEGIN_SRC cpp
  p == origin; // -> p.operator==(origin) -> operator==(point, origin)
  #+END_SRC
  zwei weitere Funktionen:
  - neuen Punkt erzeugen, transponiert, das heißt x- und y-Koordinate vertauscht.
  - verschoben um Punkt
  #+BEGIN_SRC cpp
  class Point {
	  // ... wie zuvor
	  Point transpose() const {
		  Point res((*this).y(), (*this).x());
		  return res;
	  }
	  Point translate(Point v) const {
		  Point res((*this).x() + v.x(), (*this).y() + v.y());
		  return res;
	  }
  }
  #+END_SRC
  Jede Klasse hat bestimmte spezielle Member-Funktionen:
  - Konstruktoren bringen Objekt in wohldefinierten Anfangszustand
  - Destruktoren: Entsorgt ein nicht mehr benötigtes Objekt (meist am Ende der Umgebung)
  - Zuweisungsoperatoren: um Objekt per Zuweisung ("=") zu überschreiben $\implies$ später
** Destruktoren
   jede Klasse muss genau einen Destruktor haben, wenn der Programmierer das nicht explizit implementiert,
   fügt Compiler ihn automatisch ein. Syntax:
   #+BEGIN_SRC cpp
   class klassenName {
   public:
	   ~klassenName(){
		// Implementation
		}
   };
   #+END_SRC
   Der automatische Destruktor ruft einfach die Destruktoren aller Member-Variablen auf. Meist ist
   das ausreichend, aber in bestimmten Situationen muss der Programmierer zusätzliche Aktionen implementieren.
   Beispiele dafür:
   1. manuelle Speicherverwaltung: Destruktor muss nicht mehr benötigten Speicher an
	  Betriebssystem zurückgeben ($\implies$ später), zum Beispiel Destruktor von
	  std::vector, std::string (Kapselung: Benutzer merken davon nichts)
   2. manuelles Dateimanagement: Destruktor muss Datei schließen, also Dateien aus
	  dem Festplattencache auf Platte übertragen und Metadaten für Datei schreiben, zum Beispiel
	  std::ofstream, std::ifstream
   3. Abmelden von einem Service (ausloggen, Verbindung beenden)
** Kopier-Konstruktor
   Spezieller Konstruktor: Kopier-Konstruktor zum Erzeugen einer Kopie eines vorhandenen Objekts,
   das heißt neue Speicherzelle mit gleichem Inhalt.
   #+BEGIN_SRC cpp
   Point p(1.0, 2.0); // Konstruktor mit Initialwert
   Point q = p;       // Kopierkonstruktor
   Point r(p);        // Kopierkonstruktor

   int foo(Point q) {
	   // ...
   }
   int bar(Point const & g) {
	   // ...
   }
   int main() {
	   Point p(1.0, 2.0);
	   foo(p) // Kopierkonstruktor, um lokales q in foo aus p zu erzeugen, "pass-by-value"
	   bar(p) // g ist neuer Name für p, keine neue Speicherzelle, kein Kopierkonstruktor, "pass-by-reference"
   }

   // Syntax:
   class KlassenName {
   public:
	   klassenName(klassenName const & existing) {
	   // ...
	   }
   };
   #+END_SRC
   Der Compiler erzeugt Kopier-Konstruktor automatisch, falls nicht explizit programmiert = ruft Kopier-Konstruktor
   aller Member-Variablen auf, meistens richtig, Ausnahmen wie oben.
** Standard-Konstruktor
   Spezieller Konstruktor: Standard-Konstruktor ("default constructor"): ohne Argumente,
   bringt Objekt in Standard-Zustand, zum Beispiel "0" bei Zahlen, "" bei (Leerstring) bei std::string,
   leeres Array std::vector, (0, 0) bei Point. Syntax:
   #+BEGIN_SRC cpp
   class klassenName {
   public:
	   klassenName() {}
	   klassenName() : Initialisierungswerte der Member-Variablen {}
   };
   #+END_SRC
   Compiler erzeugt Standard-Konstruktor automatisch, falls es *keinen* benutzerdefinierten Konstruktor gibt.
** rule of three
   "rule of three": Faustregel: wenn es notwendig ist, eine der drei Funktionen Destruktor, Kopierkonstruktor,
   Kopier-Zuweisung ($\implies$ später) explizit zu implementieren, müssen alle drei explizit implementiert werden
** Vorteile der Kapselung:
   1. Benutzung der Klasse ist viel einfacher, weil unwichtige Details verborgen sind
   2. interne Implementation kann geändert werden, ohne den Benutzer zu Folgeänderungen zu zwingen,
	  weil externe Schnittstelle erhalten bleibt.
** Arithmetische Infix-Operationen
   Ziel der OO-Programmierung: Arbeiten mit Nutzer-definierten Datenstrukturen möglichst einfach, wie mit eingebauten. Zum Beispiel arithmetische Infix-Operationen
   #+BEGIN_SRC cpp
   Point p(2.0, 3.0), q(4.0, 5.0);
   Point r = 2.5 * p + q;
   assert(r == Point(9.0, 12.5));
   #+END_SRC
   dazu muss man die entsprechenden Präfix-Funktionen implementieren
   - Addition:
     #+BEGIN_SRC cpp
     Point operator+(Point p1, Point p2) {
         Point res(p1.x() + p2.x(), p1.y() + p2.y());
         return res;
     }

     Point operator+(Point & p1, Point & p2) {
         Point res(p1.x() + p2.x(), p1.y() + p2.y());
         return res;
     }
     #+END_SRC
   - Subtraktion, elementweise Multiplikation und Division genauso ("+" überall durch "-", "*", "/" ersetzen)
   - Skalierungsoperation: Multiplikation von Punkt mit Zahl, das heißt zwei verschiedene Argumenttypen
	 $\implies$ zwei Versionen: 2.5*p und p*2.5
     #+BEGIN_SRC cpp
     Point operator*(double s, Point p) {
         Point res(s * p.x(), s * p.y());
         return res;
     }

     Point operator*(Point p, double s) {
         Point res(p.x() * s, p.y() * s);
         return res;
     }
     #+END_SRC
     alle diese Versionen können dank "function overloading" gleichzeitig implementiert sein
   Bisher: freie Funktionen. Falls das erste Argument vom Typ Point oder Point const & ist,
   kann man die Funktionen alternativ als Member-Funktion implementieren:
   #+BEGIN_SRC cpp
   class Point {
       // ... wie bisher
       Point operator+(Point const & other) const {
           Point res(x_ * other.x_, y_ * other.y_);
           return res;
       }
   };
   #+END_SRC
   Vorteil von Member Funktionen: Zugriff auf private Member der Klasse (hier nicht notwendig). \\
   Nachteil:
   - nur möglich, wenn das linke Argument vom Klassentyp ist p*2.5 kann Member Funktion sein, 2.5*p nicht
   - nur möglich,wenn man die Klassendefinition ändern darf
** Objekte nachträglich verändern
   Bisher: Alle Objekte waren write-once, das heißt Speicher wurde im Konstruktor initialisiert und
   war dann unveränderlich. $\implies$ Paradigma der funktionalen Programmierung - "referentielle Integrität"
   Prozedurale Programmierung erfordert Möglichkeit, Objekte zu ändern, zum Beispiel um entsprechende Änderungen in der realen
   Welt widerzuspiegeln (zum Beispiel Student besteht Prüfung). Möglichkeit 1: Setter-Funktionen
   #+BEGIN_SRC cpp
   class Point {
       // ... wie bisher

       void setX(double new_x) {
           x_ = new_x;
       }

       void setY(double new_y) {
           y_ = new_y;
       }
   };
   #+END_SRC
   Möglichkeit 2: Index-Zugriff, wie bei std::vector
   #+BEGIN_SRC cpp
   Point p(2, 3);
   assert(p[0] == 2 && p[1] == 3);
   p[0] = 4;
   p[1] = 5;
   assert(p[0] == 4 && p[1] == 5);

   // dazu muss die Member-Funktion operator[] implementiert werden
   class Point {
       // ... wie bisher

       double operator[](int index) const {
           if(index == 0) { return x_; }
           if(index == 1) { return y_; }
           // andernfalls Fehlermeldung (Exception -> später)
       }

       double operator[](int index) {
           // Implementation identisch / gleicher Quellcode, aber
           // unterschiedlicher Maschinencode
       }
   }

   // Verwendung (Langform):
   Point p(2.0, 3.0);
   double & x = p[0]; // neue Namen x, y für Variablen p.x_ und p.y_
   double & y = p[1];
   x = 4.0; // ändert indirekt auch p.x_
   y = 5.0; // ändert indirekt auch p.y_
   #+END_SRC
   Möglichkeit 3 : Zuweisungsoperatoren
   #+BEGIN_SRC cpp
   Point p(2, 3), g(4, 5);
   p = 1.0; // beide Koordinaten mit 1.0 überschreiben
   assert(p == Point(1.0, 1.0)) p = q; // Speicherzelle p werden die gleichen
                                       // Werte zugewiesen wie Speicherzelle q
   assert(p == Point(4.0, 5.0)) Point & r =
       q; // Gegensatz r und q sind Namen für gleiche Speicherzelle

   class Point {
       // ... wie bisher

       void operator=(double v) {
           x_ = v;
           y_ = v;
       }

       // copy assignment operator (analog zu copy constructor)
       operator=(Point const & other) {
           x_ = other.x_;
           y_ = other.y_;
       }
   }
   #+END_SRC
   Bemerkung:
   1. implementiert der Programmierer keinen copy assignment Operator, implementiert
	  Compiler ihn automatisch (wie Kopierkonstruktor): ruft copy assignment für alle Member-Variablen auf
   2. man implementiert meist
   #+BEGIN_SRC cpp
   Point & operator=(...) {
       // ... wie bisher
       return *this;
   }
   #+END_SRC
   Vorteil: man kann Zuweisung verketten:
   #+BEGIN_SRC cpp
   r = p = q; // -> r = (p = q)
   #+END_SRC
   arithmetische Zuweisung:
   #+BEGIN_SRC cpp
   Point p(2, 3),
   q(4, 5);
   p += q; // add -asign: Abkürzung für p = p + q
   assert(p == Point(6, 8));

   class Point {
       // ... wie bisher
       Point & operator+=(Point const & other) {
           x_ += other.x_;
           y_ += other.y_;
           return *this;
       }
   };
   #+END_SRC
** Klasse Image
   Speichert 2D Bild (analog: Matrix) zunächst nur Graubilder, später: Farbbilder.
   Beispiel für dynamische Datenstruktur, Größe erst zu Laufzeit bekannt und änderbar.
   Besteht aus Pixeln ("picture elements"), die mit 2 Indizes x und y angesprochen werden
   Problem: Speicher ist 1-dimensional, Lösung: Lege Zeilen hintereinander ab.
   $\implies$ Übergangsformeln:
   \begin{align*}
   i &= x + y \cdot width \\
   x &= 1 %% width \\
   y &= \frac{1}{width}
   \end{align*}
   #+BEGIN_SRC cpp
   class Image {
       int                   width_, height_;
       std::vector<uint16_t> data_;

   public:
       Image() : width_(0), height_(0) {}
       Image(unsigned int w, unsigned int h)
           : width_(w), height_(h), data_(w * h, 0) {}
       int  width() const { return width_; }
       int  height() const { return height_; }
       int  size() const { return width_ * height_; }
       void resize(unsigned int w, unsigned int h) {
           width_  = w;
           height_ = h;
           data.resize(w * h);
       }
       uint16_t get(int x, int y) const { return data_[x + y * width_]; }
       void set(int x, int y, uint16_t v) { data_[x + y * width_] = v; }

       // Zugriff bequemer: wünschenswert:
       // uint16_t v = image[1, 2];
       // image[1, 2] = 255;
       // geht nicht, weil im Indexoperator nur 1 Argument sein darf
       // -> verwende Stattdessen runde Klammern
       uint16_t operator()(int x, int y) const {
           return get(x, y); // return data_[x + y * width_];
       }
       uint16_t operator()(int x, int y) {
           return return data_[x + y * width_];
       }
       // damit: uint16_t = image(1, 2); image(1, 2) = 255;
   };


   std::string to_string(Image const & im) {
       std::string res;
       for(int x = 0; x < im.width(); x++) {
           for(int y = 0; y < im.height(); y++) {
   			   res += std::to_string(im(x, y)) + " ";
           }
   		   res.pop_back();
   		   res += "\n";
       }

   	   return res;
   }
   #+END_SRC
   PGM-Format ("Portable GrayMap"): reines Textformat:
   my_image.pgm:
   #+begin_example
   P2
   # Kommentar
   <width> <height>
   255
   Ausgabe von to_string
   #+end_example
** Verschiedene Konstruktoraufrufe
   Vor c++11 gab es nur () oder gar keine Klammern (Standardkonstruktor).
   #+BEGIN_SRC cpp
   std::vector<int> v0; // leeres Array
   std::vector<int> v1(10, 1); // 10 Elemente mit Initialwert 1
   std::vector<int> v2(v1); // Kopierkonstruktor
   std::vector<int> v3(v1.begin(), v1.end()); // Kopie mittels Iteratorpaar
   #+END_SRC
   Nachteil: Initialisierung mit Array-Literal wurde nicht unterstützt: c++11 schließt Lücke mittels \{\}
   #+BEGIN_SRC cpp
   std::vector<int> v4{1, 2, 3, 4}; // vier Elemente
   #+END_SRC
   Problem: neue Syntax \{\} muss rückwärtskompatibel zu allen () sein $\implies$ komplizierte Regeln
   1. gibt es einen Konstruktor mit $k$ Argumenten und einen Array-Konstruktor (mit beliebig vielen Argumenten) rufen () den k-Argument-Konstruktor auf, \{\} den Array-Konstruktor:
      #+BEGIN_SRC cpp
	  std::vector<int> v1(10, 1); // Konstruktor mit 2 Argumenten, 10 Elemente mit Wert 1
	  std::vector<int> v5{10, 1}; // Array-Konstruktor: 2 Elemente mit Wert 10 und 1
      #+END_SRC
	  Der Array-Konstruktor hat als Argument den Typ std::initializier_list<ElementTyp>.
	  Beispiel(Hausaufgaben): verhält sich ähnlich zu std::vector (Indexschleifen, Kopieren, Iteratoren)
      #+BEGIN_SRC cpp
	  class Polynomial {
	      std::vector<int> a_;

	  public:
	      Polynomial(std::initializier_list<int> l) : a_{l} {} // kopiere das Initialarray l

	      Polynomial(std::initializier_list<int> l) : a_{l.size()} {
		      for(int i = 0; i < l.size(); i++) {
		          a_[i] = l[i];
		      }
		  }
	  };

	  Polynomial p{1, 2, 3}; // \(1 + 2x + 3x^2\)
      #+END_SRC
   2. gibt es keinen Array-Konstruktor (kein Argument std::initializer_list) sind () und \{\} #äquivalent
      #+BEGIN_SRC cpp
	  Point p1(2, 3); // \(x\equiv 2, y\equiv 3\)
	  Point p2{2, 3}; // \(x\equiv 2, y\equiv 3\)
      #+END_SRC
   weitere Regeln: googeln nach "universal construction c++" $\implies$ für Fortgeschrittene
** Fehlermeldungen mittels Exceptions ("Ausnahmen")
   Normalerweise werde Funktionen mit "return" beendet. Tritt in der Funktion ein Fehler auf, kann man
   den Rückgabewert nicht ausrechnen $\implies$ müssen Funktion anders verlassen. Exceptions
   verlassen Funktion mittels "throw" (werfen)
   - Argument von throw (Rückgabewert) ist ein Exception-Objekt, das den Fehler beschreibt (zum Beispiel Fehlermeldung)
   - vordefinierte Exceptionsklassen im Header <stdexcept>, kann auch eigene definieren. Zum Beispiel std::runtime_error "Universalfehler"
   #+BEGIN_SRC cpp
   class Point {
   // ... wie zuvor

       double operator[](int index) const {
           if(index == 0) {
               return x_;
		   }
           if(index == 1) {
               return y_;
           }
           throw std::runtime_error("Point::operator[]: index out of bound");
       }
   };
   #+END_SRC
   In der aufrufenden Funktion: wirft ein Funktionsaufruf eine Exception, wird standardmäßig die aufrufende Funktion ebenfalls mit "throw" beendet, wobei
   das Exception-Objekt weitergegeben wird.
   #+BEGIN_SRC cpp
   void foo() {
       Point p(2, 3);
       p[2] = 5; // Exception: index 2 verboten $\implies$ foo wird auch beendet foo wird auch beendet
   }

   int main() {
       foo(); // Exception $\implies$ main wir auch beendet und damit das Programm. Alte Compiler geben dann einfach "abort" aus $\implies$ vermeiden durch try/catch, neue Compiler geben die Fehlermeldung aus
   }
   #+END_SRC
   Um die Exception zu "fangen" und zu behandeln (zum Beispiel Fehler reparieren und retry) bracht man
   eine try/catch-Umgebung
   #+BEGIN_SRC cpp
   try {
       foo(); // Aufruf, der Exceptions werfen könnte
       // ... weiterer Code, wenn foo() geklappt hat
   } catch(std::runtime_exception & e) { // Alternativumgebung, wenn foo() Exception wirft
       std::cerr << "Exception aufgetreten: " << e.what() << std::endl;
   }
   #+END_SRC
   Prinzip:
   - tritt im try-Block eine Exception auf, wird der Block verlassen $\implies$ die Anweisungen im try-Block *hinter* dem fehlerhaften Aufruf werden nicht mehr ausgeführt
   - folgt ein catch mit passendem Exception-Typ, springt die Ausführung in diesen catch-Block $\implies$ es kann beliebig viel catch-Blöcke für verschiedene Exceptions geben
   - Universal-Catch-Block:  catch(std::exception & e) fängt alles auf (genauer: alle von std::exception abgeleiteten Exceptions-Vererbung $\implies$ später)
   Beispiel: warten auf korrekte Benutzereingabe
   #+BEGIN_SRC cpp
   void process_user_input() {
       double input = 0.0;
	   bool input_valid = false;
	   while(!input_valid) {
	       try {
		       input = get_user_input(); // wirft runtime_error, wenn falscher Input
			   input_valid = true;
		   } catch(std::exception & e) {
		       std::cerr << "falsche Eingabe: " << e.what() << "\n versuche es nochmal!\n";
		   }
	   }

	   // verarbeite Input
   }
   #+END_SRC
** Template-Klassen
   Wir hatten: Template-Funktionen
   #+BEGIN_SRC cpp
   template<typename T>
   T sq(T x) { return x * x; }
   #+END_SRC
   Beispiel: Image-Klasse soll beliebige Pixeltypen unterstützen, bisher uint16_t, danach auch uint8_t (Speicher sparen), float(Genauigkeit bei Bildanalyse), RGB-Typ (Farbbilder).
   Vorgehen bei der Templatisierung
   1. Implementiere Klasse und Tests *ohne* Template (hier: fest definierter Pixeltyp uint16_t) $\implies$ können nach und nach Templatisieren und jeden Schritt durch Test prüfen (gehen die Tests nicht mehr, haben wir einen Fehler gemacht und müssen den
      letzten Schritt rückgängig machen und anders versuchen)
   2. Neue Typnamen einführen mit typedef OldType NewType
	  1. in der Testfunktion
         #+BEGIN_SRC cpp
		 void test_image_uint16_t() {
		 typedef Image Img; // wird später zu typedef Image<uint16_t> Img
		     Img img(10, 20); // Breite 10, Höhe 20
		     assert(img.width() == 10);
		     assert(img.height() == 20);
		     assert(img(0, 0) == 0);
		     img(0, 0) = 255;
		     assert(img(0, 0) == 255);
		 }
         #+END_SRC
	  2. in der Klasse für den Pixeltyp alle Vorkommen von uint16_t (als Pixeltyp) durch "PixelType" ersetzen $\implies$ alle Tests müssen weiterhin funktionieren, weil nur neue Typnamen, gleiche Funktionalität
         #+BEGIN_SRC cpp
		 class Image {
		     int width_, height;
		     std::vector<uint16_t> data_;
		 public:
		     uint16_t operator()(int x, int y) {
		         return data[x + y * width_];
		     }

		     // ...
		 };
         #+END_SRC
		 $\to$
         #+BEGIN_SRC cpp
		 class Image {
		 public:
		     typedef uint16_t PixelType;
		 private:
		     int width_, height;
		     std::vector<PixelType> data_;
		 public:
		     PixelType operator()(int x, int y) {
		         return data[x + y * width_];
		     }

		     // ...
		 };
         #+END_SRC
   3. Klasse templatisieren: typedef aus 1. durch Template-Deklaration ersetzen
      #+BEGIN_SRC cpp
	  template<typename PixelType>
	  class Image {
	  // wie zuvor, nur ohne typedef
	  };
      #+END_SRC
   4. Tests anpassen:
	  1. typedef aktualisieren
         #+BEGIN_SRC cpp
		 void test_image_uint16_t() {
		     typedef Image<uint16_t> Img; // überall, wo Img verwendet wird, hat sich jetzt automatisch der Typ von Image nach Image<uint16_t> geändert
		 }
         #+END_SRC
	  2. freie Funktionen sind noch nicht templatisiert $\implies$ vorübergehend auskommentieren, ebenso
		 die zugehörigen Tests (zum Beispiel to_string(), readPGM(), writePGM())
	  3. verbleibende Tests ausführen, müssen immer noch funktionieren
	  (die Typdeklaration Image<uint16_t> wird vom Compiler so implementiert, dass in der Templateklasse Image alle Vorkommen des Typ-Platzhalters "PixelType" durch den Type "uint16_t" ersetzt werden.
      Das ist "Template Instanziierung", das heißt erzeugen einer echten Klasse aus einer Template-Klasse)
   5. *eine* freie Funktion auswählen, wieder einkommentieren (zusammen mit ihren Tests) und templatisieren, zum Beispiel
      #+BEGIN_SRC cpp
	  std::string to_string(Image const & img);
	  // wird zu
	  template<typename PixelType>
	  std::string to_string(Image<PixelType> const & img);
	  // Implementation bleibt zufällig gleich in diesem Fall
      #+END_SRC
   6. Test ausführen, müssen wieder funktionieren, zurück zu Schritt 5, bis alle freien Funktionen templatisiert sind
   7. weitere Testfunktion für einen anderen Pixeltyp schreiben
      #+BEGIN_SRC cpp
	  void test_image_float() {
	  typedef Image<float> Img;
	  // ähnliche Tests wie in test_image_uint16_t(), aber *auch* mit krummen Zahlen (ging vorher nicht), klappt das *nicht*, hat man oft uint16_t irgendwo nicht durch PixelType ersetzt
	  }
      #+END_SRC
	  $\implies$ erst, wenn beide Testfunktionen laufen, kann man relativ sicher sein, das Templatisierung erfolgreich
* Adressen und Zeiger
  Bisher: Speicherzellen werden über Variablennamen angesprochen (oder mehrere Namen für gleiche Speicherzelle, falls Referenzen).
  Adressen sind Alternative, um Speicherzelle zu identifizieren. Betrachte den gesamten Speicher des Computers als *ein*
  riesiges Array vom Type "byte" (globaler Index vom Betriebssystem festgelegt). Der globale Index heißt
  Adresse des bytes. Die Adresse des ersten Bytes einer Speicherzelle heißt Adresse der Speicherzelle.
  $\implies$ kennt man die Adresse einer Speicherzelle und ihren Typ, kann man den Speicher genauso identifizieren wie
  mit Variablenklammern. Konvention: die Adresse $0$ wird nicht verwendet $\implies$ interpretiert als "ungültige Adresse".
  Die Adresse einer Speicherzelle kann von einer Variable mit dem Adressoperator erfragt werden. (unäre &-Operator)
  #+BEGIN_SRC cpp
  int i = 3;
  std::cout << "Adresse von i: " << &i << std::endl; // Nicht mit binärem und-Operator verwechseln
  #+END_SRC
  Adressen werden Standardmäßig im Hexadezimalformat angezeigt. Hex: zur Basis 16, Ziffer 0-9,a-f, Prefix: 0x. Zum Beispiel
  |    0x1 |     1 |
  |    0xa |    10 |
  |    0xe |    14 |
  |   0x10 |    16 |
  |   0x11 |    17 |
  |   0x1a |    26 |
  | 0xbeaf | 48815 |
  "Zeiger" sind spezielle Variablen, mit denen man Adressen speichern kann. (englisch Pointer)
  #+BEGIN_SRC cpp
  int i = 3;
  int * ptr_i = &i; // Initialisierung
  int * ptr2 = ptr_i; // Kopierkonstruktor: weiterer Zeiger mit der selben Adresse wie ptr_i
  int * ptr3 = 0; // ungültige Adresse

  if(!ptr3) {
  // ungültige Adresse
  } else {
  // gültige Adresse
  }
  #+END_SRC
  Um vom Zeiger zur Variablen zurückzukommen, benutzt man den Dereferenzierungsoperator * (von Iteratoren bereits bekannt) $\implies$ Ergebnis: Referenz auf die Speicherzelle, die bei der Adresse beginnt
  #+BEGIN_SRC cpp
  int i = 3;
  int * ptr_i = &i;
  int &j = *ptr_i; // j ist neuer Name für i, äquivalent zu int & j = i;
  j = 5; // i ändert sich auch
  *ptr_i = 7; // i und j ändern sich, Schreibender Zugriff über den Zeiger, Compiler legt intern eine temporäre Referenz an
  int k = *ptr_i; // eine neue Variable mit dem selben Wert wie *ptr_i (= 7
  #+END_SRC
  Adressoperator und Dereferenzierungsoperator sind invers: für alle Variablen gilt:
  #+BEGIN_SRC cpp
  assert(i == *(&i));
  #+END_SRC
  Nulltes Argument von Member-Funktionen ist eigentlich ein *Zeiger* auf die Adresse des aktuellen
  Objekts this: Zeiger, wir haben daraus Referenz erzeugt (*this)
** Wozu verwendet man Zeiger?
   Heute versucht man, Zeiger so weit wie möglich in Objekte zu kapseln $\implies$ einfacher, weniger Fehler
   zum Beispiel std::vector versus old-type C-Arrays. In C gibt es noch keine Referenzen $\implies$
   benutze Zeiger um Referenzen zu simulieren:
   C++:
   #+BEGIN_SRC cpp
   void foo(int & i) {
       i = 5;
   }

   int j = 3;
   foo(j);
   assert(j == 5);
   #+END_SRC
   C:
   #+BEGIN_SRC cpp
   void foo(int * i) {
       *i = 5;
   }

   int j = 3;
   foo(&j);
   assert(j == 5);
   #+END_SRC
   $\implies$ wenn man aus c++ eine Bibliothek aufrufen (zum Beispiel um TIFF oder JPEG zu erzeugen) braucht man oft Zeiger.
** Anwendungen der Zeiger
   1. Ersatz für Referenzen (bis in C)
   2. für Variablen, die auch ungültig sein können
	  1. für optionale Argumente:
         #+BEGIN_SRC cpp
		 int foo(int * a = 0) { // Default Argument, setzt der Compiler automatisch ein, wenn Benutzer es nicht angibt
		     if(a == 0) { // ungültige Adresse $\implies$ Benutzer hat kein Argument übergeben
			     // Berechnung mit einem Standard-Wert für a
			 } else {
			     // Berechnung mit gegebenem Wert (*a)
			 }
		 }

		 // Verwendung:
		 foo(0); // Nullpointer $\iff$ ungültig $\implies$ Standardberechnung
		 int a = 2;
		 foo(&a); // Berechnung mit Wert = 2
		 foo(); // Compiler mach daraus automatisch foo(0);
         #+END_SRC
	  2. wenn eine Funktion fehlschlägt: (typisch für C). Öffnen einer Datei in C:
         #+BEGIN_SRC cpp
		 FILE * file = fopen("filename");
		 if(!file) { // ungültige Adresse
		     std::cerr << "unable to open file: filename" << std::endl;
			 return; // throw
		 }
		 // file lesen
         #+END_SRC
		 bessere Lösung in c++: kapseln und bei Fehler Exception werfen $\implies$ if(file == 0) kann nicht vergessen werden.
	  3. Variablen, die nacheinander auf verschiedene Speicherzellen zeigen, typisch: "Iteratoren" in c
         #+BEGIN_SRC cpp
		 int array[100]; // C-Array, Größe 100
		 int * iter = &(a[0]); // Zeiger auf erstes Element $\estimates$ std::vector.begin()
		 int * end = iter + 100; // Zeiger hinter letztes Element $\estimates$ std::vector.end()

		 int c = 0;
		 for(;iter != end; iter++, c++) {
		     *iter = c; // Array mit 0, 1, 2, 3, $\ldots$, 99 initialisieren
		 }
         #+END_SRC
		 Syntax wie bei Iteratoren, weil Iteratoren nach dem Vorbild der Zeiger definiert wurden.
	  4. manuelle Speicherverwaltung:
		 - Speicherzellen, die mit Schlüsselwort "new" angelegt wurden, gibt der Compiler am Ende der Umgebung *nicht* automatisch frei
		 - wenn nicht mehr benötigt, muss der Programmierer den Speicher mit "delete" manuell freigeben
		 - das Resultat von "new" ist Adresse der Speicherzelle $\implies$ an Zeiger zuweisen
         #+BEGIN_SRC cpp
		 Image * img = 0; // Zeiger auf Bild, anfangs ungültig
		 {
		     // ... Breite und Höhe erfragen
		     img = new Image(width, height);
		 } // img wird *nicht* automatisch freigegeben
         (*img)(0, 0) = 255; // Pixel (0, 0) überschreiben
		 Image & image = *img; // Referenz auf Speicherzelle an Adresse "img"
		 image(1, 1) = 128; // Pixel (1, 1) schreiben
		 // Wichtig!!!!!!!!:
		 delete img; // Speicher händisch freigeben, nicht vergessen (sonst Speicherleck) aber auch nicht zu früh (sonst Absturz)
         #+END_SRC
		 In c++ verwende "smart pointer" std::unique_ptr, std::shared_ptr $\implies$ rufen delete automatisch im richtigem Moment auf (std::shared_ptr<Image> img = new Image(w, h))
		 Für Arrays gibt es analog new[], delete[]. Beispiel: manuelle Speicherverwaltung im Image
         #+BEGIN_SRC cpp
		 class Image {
		     int width_, height_;
		     uint16_t * data_; // war: std::vector<uint16_t> data_;
		 public:
		     Image(unsigned int w, unsigned int h) : width_(w), height_(h), data_(new uint16_t[w * h]) { // manuelle Array-Allokation
		         for(int i = 0; i < w * h; i++) {
		             data_[i] = 0;
		         }
		     }

             // Jetzt ist der automatisch generierte Kopierkonstruktor ungeeignet $\implies$ manuell implementieren
			 Image(const Image & other) : width_(other.width_), height_(other.height_), data_(new uint16_t[width_ * height_]) { // manuelle Speicher-Verwaltung
			     for(int i = 0; i < width_ * height_; i++) {
				     data_[i] = other.data_[i];
				 }
			 }

			 // analog: Kopierzuweisung manuell implementieren, "rule of three"
			 // Destruktor
			 ~Image() {
			     delete[] data_; // Array freigeben (falls delete ohne [] $\implies$ Absturz)
			 }
		 }
         #+END_SRC
	  5. Heterogene Container: normale Container (std::vector<double>) sind *homogen* $\estimates$ Elemente haben gleichen Typ (double).
		 Manchmal braucht man Container, die Objekte verschiedener Typen aufnehmen "heterogen", dafür braucht man Zeiger und *Vererbung*
* Vererbung
  Vererbung war am Anfang der objekt-orientierten Programmierung Lösung für alles. Heute ist der Hype vorbei, eine Technik unter vielen, sparsam eingesetzt, besonders
  bei GUI (graphical user interface) und bei Zeichenprogrammen/Computer Graphik. Eine Klasse (abgeleitete Klasse, Unterklasse) kann
  Funktionalität einer anderen Klasse (Basisklasse) erbe, Basisklasse muss dafür nicht sterben. Sprachunabhängige Schreibweise: UML-Diagramm ("Universal modelling language")
  #+begin_export latex
  \catcode`(=12
  \catcode`)=12
  #+end_export
  \begin{figure}[H]
  \centering
  \begin{tikzpicture}
  \umlsimpleclass{Base}
  \umlsimpleclass[y = 3]{Derived}
  \umlinherit{Base}{Derived}
  \end{tikzpicture}
  \end{figure}
  #+begin_export latex
  \catcode`(=\active
  \catcode`)=\active
  #+end_export
  in c++:
  #+BEGIN_SRC cpp
  class Base {
  // ...
  };

  class Derived : public Base { // Vererbung
      // ...
      using Base::Base; // Vererbung von Konstruktor erzwingen
  }
  #+END_SRC
  Die Funktionalität aus der Umgebung von Base ist in der Umgebung von Derived sichtbar (wie bei normalen geschachtelten Umgebungen). Ausnahmen:
  - Konstruktoren und Zuweisungsoperatoren werden *nicht* vererbt (in Derived neu implementieren, ab c++11 mit "using" Vererbung erzwingen)
  - private Member sind unsichtbar (aber noch vorhanden)
  $\implies$ in Derived die öffentliche Schnittstelle von Base benutzen. Ausnahme: ersetze "private" in Base durch "protected" $\implies$ protected Members werden in Derived sichtbar
  (aber bleiben von außen privat). Die in Derived geerbte Funktionalität gehört zur Öffentlichen Schnittstelle von Derived $\implies$ Wiederverwendung der Funktionalität vor Base.
  Ausnahme:
  - wenn Derived eine neue Member-Variable oder -Funktion mit dem gleichen Namen implementiert, wird die geerbte Variante *verdeckt* (wie bei normalen Umgebungen auch)
  - man kann die Verwendung der geerbten Version erzwingen durch Doppelpunktnotation Base:: (wie bei Namensräumen std::), Base::data_, Base::foo()
  Im Konstruktor von Derived wird der Konstruktor von Base aufgerufen wie ein Konstruktor der Membervariablen
  #+BEGIN_SRC cpp
  class Base {
      int b_;
  public:
      Base(int b) : b_(b) {}
  };

  class Derived : public Base {
      int d_;
  public:
      Derived(int b, int d) : Base(b), d_(d) {}
  };
  #+END_SRC
* Anwendung von Vererbung
** Spezialisierung
   Spezialisierung "is-a" Beziehung, Derived is a (special kind of) Base. Basisklasse: ungeordneter Container von Point-Objekten ("Punktwolke")
    #+BEGIN_SRC cpp
	class PointSet {
	    // Funktionen wie Anzahl, boundingbox bestimmen, konvexe hülle, Punkte verschieben, skalieren, zeichnen
	};
    #+END_SRC
	abgeleitete Klasse: Polygon, geordnete Punktmenge, jeder Punkt ist mit seinem Nachfolger verbunden.
    #+BEGIN_SRC cpp
	class Polygon : public PointSet {
	    // erbt Funktionalität vor PointSet
		// zusätzliche Funktionalität: Flächeninhalt, Umfang, Test: ist Punkt innen oder außen
		// veränderte Funktionalität: zeichnen
	};
    #+END_SRC
** Implementationsvererbung, Ziel: Wiederverwenden von Funktionalität, SEHR UMSTRITTEN.
   Nur in wenigen Fällen die richtige Lösung, ok ist es im Zusammenhang mit Spezialisierung, zum
   Beispiel Polygon erbt nützliche Funktionalität von PointSet. Meist bevorzugt man heute: Komposition und Delegation
   #+BEGIN_SRC cpp
   class Polynomial {
       std::vector<double> a_; // Komposition
	   // alle Operationen, die Koeffizienten betreffen, werden an Vektor a_ weitergeleitet:
	   double & operator[](int i) {
	       return a_[i]; // Delegation
	   }
   };

   // mit Vererbung:
   class Polynomial : public std::vector<double> {
       // ...
	   // operator[] jetzt geerbt
   };
   #+END_SRC
   Probleme: Man erbt auch Funktionen, die man *nicht* möchte, zum Beispiel erase(). $\implies$ dadurch ist auch der Designer von std::vector in seiner Freiheit beschränkt.
   Völlig verrückt wäre:
   #+BEGIN_SRC cpp
   class Point2D {
   protected:
       double x_, y_;
   public:
       // ....
   };

   // Ärger:
   class Point3D : public Point2D {
       double z_;
   public:
       // ...
   }
   #+END_SRC
** Interface-Vererbung
   Basisklasse definiert die öffentliche Schnittstelle, aber implementiert sie nicht. \\
   Abgeleitete Klassen implementieren die Schnittstelle auf verschiedene Art. Beispiel: Zeichenobjekte
   #+begin_export latex
   \catcode`(=12
   \catcode`)=12
   #+end_export
   \begin{figure}[H]
   \centering
   \begin{tikzpicture}
   \umlsimpleclass{Shape}
   \umlsimpleclass[y = 3, x = -5]{Line}
   \umlsimpleclass[y = 3, x = -3]{Circle}
   \umlsimpleclass[y = 3, x = -1]{Rectangle}
   \umlsimpleclass[y = 3, x = 1]{Polygon}
   \umlsimpleclass[y = 3, x = 3]{Composite}
   \umlinherit{Shape}{Line}
   \umlinherit{Shape}{Circle}
   \umlinherit{Shape}{Rectangle}
   \umlinherit{Shape}{Polygon}
   \umlinherit{Shape}{Composite}
   \end{tikzpicture}
   \end{figure}
   #+begin_export latex
   \catcode`(=\active
   \catcode`)=\active
   #+end_export
   Shape: Schnittstellenklasse("Interface"), *abstrakte* Basisklasse. \\
   Composite: Container für Shape-Objekte $\implies$ eine fertige Zeichnung kann als
   Ganzes in neue Zeichnung eingebettet werden. Interface-Vererbung ist möglich, weil
   Zeiger / Referenzen auf abgeleitete Klasse in Zeiger / Referenzen der Basisklasse konvertieren werden können.
   #+begin_src cpp
   Line line(...);
   Shape * shape = &line;

   // Gegensatz:
   int i = 3;
   double * p = &i; // verboten
   #+end_src
   $\implies$ bei dieser Konvertierung geht die Typinformation von Line nicht vollständig verloren,
   das hießt der Compiler merkt sich, dass die in shape gespeicherte Adresse zu einer Line-Speicherzelle
   gehört $\implies$ shape hat gleichzeitig zwei Type:
   - statischer Typ = Shape * = der Typ der Deklaration
   - dynamischer Typ = Line = "der ursprüngliche Typ" der Speicherzelle
   Das funktioniert, wenn die Interface-Klasse Shape mindestens eine "virtuelle" Member Funktion hat
   $\implies$ dann fügt der Compiler automatisch die notwendige zusätzliche Typinformation in die
   Speicherzelle ein
   #+begin_src cpp
   class Shape {
   public:
       virtual void draw(Image & img) const = 0;
	   virtual void drawZoomed(Image & img, double zoom) const = 0;
	   virtual ~Shape() = 0; // falls virtuelle Funktion $\implies$ virtueller Destruktor
   }
   #+end_src
   statt leerer Implementation kann man auch "abstrakte Funktionen" definieren, ganz
   ohne Implementation $\implies$ ersetze {} mit = 0; (Aufruf führt dann zu Fehlermeldung)
   $\implies$ dann ist auch die ganze Klasse abstrakt. (Fehlermeldung beim Konstruktoraufruf),
   Zeiger sind erlaubt.
   Jede abgeleitete Klasse muss die virtuellen Funktionen implementieren:
   #+begin_src cpp
   class Line : public Shape {
       Point start_, end_, uint16_t color;
   public:
       Line(Point s, Point e, uint16_t color) : start_(s), end_(e), color_(color) {}
	   virtual void draw(Image & img) const {
	       // benutze Bresenham-Algorithmus um in img eine Line von start_ nach end_ zu zeichnen mit Farbe color_
	   }

	   virtual void drawZoomed(Image & img, double zoom) {
	       // zeichne Linie von zoom * start_ nach zoom * end_
	   }

	   virtual ~Line() {} // Compiler fügt Destruktoraufrufe der Member Variablen automatisch ein
   };
   #+end_src
   Bedeutung der zwei-Typen-Regel beim Aufruf (*shape).foo();
   - normale Member Funktionen (nicht virtuell) werden mit dem statischen Typ aufgerufen:
	 - verwende Implementation im statischen Typ
	 - nulltes Argument (this-Zeiger) ist Zeiger auf statischen Typ
   - virtuelle Memberfunktionen werden mit dem dynamischen Typ aufgerufen
	 - verwende Implementation der abgeleiteten Klasse
	 - Nulltes Argument ist Zeiger auf abgeleitete Klasse
   #+begin_src cpp
   Image img(width, height);
   Line line(start, end);
   Shape * shape = &line;
   (*shape).draw(img); // virtuelle Funktion $\implies$ Line::draw() wird ausgeführt
   #+end_src
*** Hauptanwendung von Interface-Vererbung
	heterogene Container $\equiv$ Elemente verschiedener Type, in c++ nicht möglich.
	Trick: verwende Zeiger auf Interface-Klasse als Elementtyp $\implies$ dynamischer Typ
	aller Elemente kann unterschiedlich sein $\implies$ Container ist heterogen bezüglich
	Aufrufen virtueller Funktionen sein.
    #+begin_src cpp
	std::vector<Shape *> drawing;
	drawing.push_back(new Line(start1, end1)); // manuelle Speicherverwaltung
	drawing.push_back(new Circle(center, radius));
	drawing.push_back(new Line(start2, end2));
	// ...
	Image img(width, height);

	for(int i = 0; i < drawing.size(); i++) {
        drawing[i]->draw(img); // ruft für jedes i die passende draw() Funktion auf $\implies$ heterogenes Array
	}
    #+end_src
	Das Composite Shape enthält ein solchen heterogenes Array als Membervariable, seine draw()-Funktion kapselt die Schleife.
	Heterogenous Container verwenden manuelle Speicherverwaltung $\implies$ man darf am Ende nicht das "delete" für die
	Elemente vergessen $\implies$ besser verwende smart pointer: std::vector<std::shared_ptr<Shape>> drawing; (delete wird automatisch aufgerufen)
** Kritik an Vererbung
   Die Vererbungshierarchie ist fest verdrahtet, *aber* in verschiedenen Kontexten braucht man eigentlich
   verschiedene Hierarchien. Zum Beispiel Person-Objekt kann je nach Situation verschiedene Rollen einnehmen
   $\estimates$ verschiedene Interface-Definitionen: Schüler, Student, Employee, Mitglied, Kunde, $\ldots$.
   Person kann nicht von all diesen Interfaces abgeleitet sein, zumal es verschiedenste Varianten gibt.
   Besser: verwalte diese Relationen in Datenbanken.
* Deklarative Programmierung
  Wir haben folgende Programmier-Paradigmen gelernt:
  - endliche Automaten
  - Maschinensprache
  - funktionale Programmierung
  - prozedurale Programmierung
  - objekt-orientierte Programmierung
  - generische Programmierung (mit Templates)
  Das sind Spezialfälle der *imperativen* Programmierung (imperare = befehlen), weil der Programmierer nicht nur angeben muss,
  *was* passieren soll, sondern im Detail, *wie* es passiert (insbesondere explizite Angabe des Kontrollflusses, if-Bedingungen, Schleifen und rekursive Funktionen).
  In deklarativen Sprachen sagt der Programmierer nur, *was* er/sie erreichen will, das ganze *wie* ist im Compiler/Interpreter der Sprache gekapselt.
  Das funktioniert in relativ engen Anwendungsdomänen ("domain specific languages"), und vereinfacht dann die Programmierung stark
** Data serialization languages
   Beispiele: XML, JSON, YAML \\
   Serialization: Umwandlung einer komplexen Datenstruktur (Array, Baum, Graph, geschachtelte Daten) in eine Bytefolge, die auf Festplatte gespeichert und über Netzwerk gesendet werden kann \\
   Deserialization: Aus der Bytefolge die Datenstruktur wieder zusammenbauen. \\
   Serialization *languages*: Bytefolge ist ein Textfile, das man mit normalen Editoren anschauen / bearbeiten kann  \\
   Beispiel: JSON
   - es gibt die üblichen Literale: true/false (bool), 1234 (int), 5.67e-7 (float), "abcd" (string), null (undefiniert)
   - zusätzlich gibt es Array-Literale: [wert1, wert2, "\ldots"]
   - assoziative Array-Literale: {"key1" : wert1, "key2" : wert2, "\ldots"}
   - Array (assoziative Arrays sind heterogen (beliebige gemischte Elementtypen)), insbesondere wieder Arrays / assoziative Arrays $\implies$ Möglichkeit der beliebig tiefen Schachtelung
   #+begin_src js
   {
       "Adam Müller": {
           "Martrikel": 12345,
           "Übungspunkte": [
               38.5,
               40.0,
               0.0,
               35.0
           ],
           "Note": null
       },
       "Eva Heller": {
           "Martrikel": 67890,
           "Übungspunkte": [
               10.0,
               15.0
           ],
           "Note": null
       }
   }
   #+end_src
   deklarativ: Programmierer sagt nicht, *wie* aus der Beschreibung eine c++ Datenstruktur gebaut wird.
** document description languages, markup languages
   Zum Beispiel: HTML, Markdown, \LaTeX (teilweise auch imperativ) \\
   Textdokumente mit dem eigentlichen Text *und* Formatierungsanweisungen. \\
   HTML:
   #+begin_src html
   <h1>Hauptüberschrift</h1>
   <h2>Unterüberschrift</h2>
   <p>Absatz-mehrere Sätze</p>
   <ul>
   <li> erster Anstrich </li>
   <li> zweiter Anstrich </li>
   </ul>
   #+end_src
   - sehr mächtig
   - Attribute zur weiteren Verfeinerung <h1 style="color:blue">Hauptüberschrift</h1>
	 (typischerweise in separaten Style-Files .css)
   #+begin_example
   Hauptüberschrift
   ================
   Unterüberschrift
   ________________

   Absatz (durch Leerzeilen getrennt).

   Aufzählung:
   * erster Anstrich
   * zweiter Anstrich
   #+end_example
   - lesbarer als Text mit < $\ldots$ >
   - einfacher zu schrieben
   - wird vom Markdown-Compiler nach HTML konvertiert
   - weniger leistungsfähig (weniger Formatierungsoptionen)
** SQL
   SQL ("structured query language") zur Kommunikation mit relationalen Datenbanken
   - relative Datenbank:
	 - Sammlung von Tabellen mit Querverweisen
	 - Tabelle:
       - Spalten (Felder, Attribute) $\estimates$ Membervariablen einer Datenstruktur
	   - Zeilen (Records) $\estimates$ Instanzen der Datenstruktur
       | Matrikel | Name   | Vorname | Fach           |
       |----------+--------+---------+----------------|
       |    12345 | Müller | Adam    | Informatik BSC |
       |    67890 | Heller | Eva     | Physik BSC     |
   Sprache SQL enthält Befehle zum
   - Tabellen anlegen und verändern (zum Beispiel neue Spalte einfügen)
   - Daten in Tabelle einfügen und modifizieren
   - Daten in Tabellen nach bestimmten Kriterien *suchen*
   aber: sagt nicht, wie die Daten auf Platte/im RAM abgelegt sind oder wie die Suche funktioniert
   #+begin_src sql
   SELECT Vorname, Name
   FROM Teilnehmer
   WHERE Fach="Physik BSC"
   #+end_src
   $\implies$ Eva Heller
** Logikprogrammierung mit PROLOG
   PROLOG (PROgrammiation en LOGique) \\
   Programmierer definiert ("deklariert") Fakten und Regeln, die in der jeweiligen Anwendung gelten. \\
   Programmierer definiert ("deklariert") das Ziel der Berechnung durch Anfragen (queries).
   Computer Benutzt intern die allgemeinen Schlussregeln der Logik ("Prädikatenlogik erster Stufe")
   um die Anfrage zu beantworten, zum Beispiel
   - Beweis, dass Aussage wahr oder falsch
   - Menge aller Symbole, die die Anfrage erfüllen
   Stammbaum:
   #+begin_src prolog
   % Fakten
   mann(A).
   mann(T).
   frau(E).
   frau(D).
   frau(U).
   vater(A,T).
   vater(T,F).
   vater(T,U).
   mutter(E,T).
   mutter(D,F).
   mutter(D,U).

   % Regeln
   grossvater(X,Y) :-
   vater(X,Z),
   vater(Z,Y).
   grossvater(X,Y) :-
   vater(X,Z),
   mutter(Z,Y).

   % Anfragen
   ?-mann(A). % yes.
   ?-frau(E). % yes.
   ?-mann(E). % no.
   ?-mann(H). % no.
   ?-grossvater(A, U). % yes.
   ?-grossvater(X, F). % X=A
   #+end_src
** formale Grammatiken
   Beispiel: BNF (Bachus-Nauer-Form). \\
   Spezifizieren die formale Struktur (Syntax) einer anderen Programmiersprache, was sind gültige
   Befehle und Programme. Computer für die spezifizierte Sprache checkt zuerst die Grammatik $\implies$
   wenn verletzt Fehlermeldung ("Syntax error"). Bestehen aus Ableitungsregel \\
   <neuer Begriff> ::= Definition (viele syntaktische Variablen) \\
   Beispiel: Teil von c++
   #+begin_src bnf
   <Ziffer> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
   <positiveZahl> ::= <Ziffer | <Ziffer><positiveZahl>
   <ganzeZahl> ::= ["x" | "-"]<positiveZahl>
   <kommaZahl> ::= <ganzeZahl>"."<positiveZahl> | <ganzeZahl>"." | "."<positiveZahl>
   <FließpunktZahl> ::= <kommaZahl>["E" | "e"]<ganzeZahl> | <ganzeZahl>["E" | "e"]<ganzeZahl>
   <alphabetic> ::= "a" | "b" | ... | "A" | "B" | ... | "Z" | " "
   <Bezeichner> ::= <alphabetic>{<alphabetic> | <Ziffer> }
   <Argument> ::= <Bezeichner" "<Bezeichner>
   <ArgumentListe> ::= "" | <Argument> | <Argument>","<ArgumentListe>
   <Funktionsdeklaration> ::= <Bezeicher>" "<Bezeichner>"("<ArgumentListe>");"
   #+end_src
** Reguläre Ausdrücke
   Reguläre Ausdrücke: Suchen und ersetzen mit Jokerzeichen, seit c++11: Header <regex>
* Wiederholung
** Pointer und Referenzen
   #+begin_src cpp
   // ursprünglicherTypename neuerTypname
   typedef int *     int_ptr;   // Zeiger
   typedef int &     int_ref;   // Referenz
   typedef int const const_int; // write-once integer
   typedef const_int *
   const_int_ptr; // äquivalent typdef int const * int_const_ptr
   typedef const_int & const_int_ref;

   int     a = 0;
   int_ref b = a; // äquivalent: int & b = a;
   b         = 3;
   int_ptr p = &a; // äquivalent: int * p = &a;
   *p = 5; // Compiler mach daraus: int_ref tmp1 = *p; tmp1 = 5; (hier wird tmp1
   // wieder gelöscht)
   // generell: temporäre interne Variablen / Referenzen werden beim Semikolon
   // gelöscht
   int c = *p; // Compiler: int_ref tmp2 = *p; int c = tmp2;
   p     = &c;
   (*p)  = 7; // $\implies$ int_ref tmp3 = *p; tmp3 = 7;

   void foo(int f) { f = 4; }

   void bar(int_ref g) { g = 4; }

   void baz(const_int_ref h) { std::cout << h; }

   foo(a); // pass-by-value
   bar(a); // pass-by-reference
   baz(a); // pass-by-const-reference

   class Point {
        int x, y;

   public:
       Point(int x, y) : x(x), y(y) {}
       int getX() const { return x; }
       int_ref getX() { return x; }
   };

   Point g(1, 2);    // sizeof(Point) == 8
   a  = g.getX();    // Compiler: int_ref tmp4 = g.getX(); a = tmp4;
   p  = &(g.getX()); // int_ref tmp5 = g.getX(); p = &tmp5;
   *p = 8;           // int_ref tmp6 = *p; tmp6 = 8;

   Point const & gg = g;         // read only Name
   a                = gg.getX(); // Kumulier: int tmp7 = gg.x; a = tmp7;
   #+end_src
** Wiederholung Komplexität:
   $\mathcal{O}$ -Notation
   komplizierte Formen $f(n)$, einfache Formel $g(n)$, die das gleiche *wesentliche* Verhalten
   wie $f(n)$ hat. Asymptotische für große $n$ ununterscheidbar
   \[f(n) \in \mathcal{O}(g(n)) \iff \Exists n_0, c: \Forall n > n_0: f(n) \leq c g(n)\]
   Diagramme für $f(n)$ und $cg(n)$ sehen für für $n > n_0$ fast gleich aus.
   wichtige Regeln:
   1. konstante Faktoren werden von $\mathcal{O}$ absorbiert $d f(n) \in \mathcal{O}(f(n)), d\mathcal{O}(f(n)) \in \mathcal{O}(f(n))$
   2. Produkte von $\mathcal{O}$ werden zum $\mathcal{O}$ der Produkte $\mathcal{O}(f(n)) \mathcal{O}(g(n)) \in \mathcal{O}(f(n)g(n))$
   3. In einer Summe überlebt nur der *wichtigste* (am schnellsten wachsende) Term
		 \[\mathcal{O}(f(n) + g(n)) \in \begin{cases} \mathcal{O}(g(n)) & f(n) \in \mathcal{O}(g(n)) \\ \mathcal{O}(f(n)) & g(n) \in\mathcal{O}(f(n))\end{cases}\]
   4. Polynome: $n^p \in \mathcal{O}(n^p) \iff p \leq q$ Falls $f(n) = g(n) \quad\mathcal{O}(f(n) + g(n)) \in 2\mathcal{O}(f(n)) \in \mathcal{O}(f(n))$
		 \[n^{p1} + n^{p2} + n^{p3} \in \mathcal{O}(n^{\max\{p_1, p_2, \ldots\}})\]
   für große $n$:
   \begin{gather*}
   f(n) \leq g(n) \iff \frac{g(n)}{f(n)} \leq \frac{1}{c} > 0 \\
   \implies f(n) \in \mathcal{O}(g(n))\iff \lim_{n\to\infty} \frac{g(n)}{f(n)} > 0
   \end{gather*}
   #+begin_ex latex
   \begin{align*}
   f(n) &= n^2 \quad g(n) = n^3 \quad \frac{g(n)}{f(n)} = \frac{n^3}{n^2} = n \quad \lim_{n\to\infty} n = \infty > 0 \\
   f(n) &= n \quad g(n) = n\log n \quad \frac{g(n)}{f(n)} = \frac{n\log n}{n} = \log n \quad \lim_{n\to\infty} \log n = \infty > 0 \\
   f(n) &= n\log n \quad g(n) = n^2 \quad \frac{g(n)}{f(n)} = \frac{n^2}{n\log n} = \frac{n}{\log n} \quad \lim_{n\to\infty} \frac{n}{\log n} = \frac{\infty}{\infty} = \lim_{n\to\infty} n = \infty > 0 \\
   \end{align*}
   #+end_ex
   Komplexität von Algorithmen $\estimates$ Summe der Komplexitäten der Schritte $\implies$
   nach Regel 3. nur der *wichtigste* Teil
*** Sieb des Eratones
	Sieb des Eratones: finde alle Primzahlen $\leq n$. Prinzip: streiche in Liste alle zahlen, die
	Vielfache einer Zahl sind $\implies$ übrig bleibenden sind Primzahlen
	#+begin_src cpp
	std::vector<bool> find_primes(int n) {
	    std::vector<bool> res(n + 1, true); // alle Zahlen prim : \mathcal{O}(n): n SpZ auf "true" initialisieren
	    res[0] = false; res[1] = false; // keine Primzahlen : \mathcal{O}(1): Indexzugriff unabhängig von n

	    for(int k = 2, k < n, k++) { // k $\estimates$ alle Vielfachen von k
	        for(j = 2 * k, j <= n, j += k) { // n / k - 1 Schritte
	            res[j] = false; // Vielfaches von k und damit nicht prim
	        }
	    }

	    return res; // res[i] = true $\iff$ i Primzahl : \mathcal{O}(n), Array der Länge n kopieren
	}
	#+end_src
	Komplexität der Algorithmus $\estimates$ Summe der Komplexitäten der Schritte $\implies$ nach
	Regel 3 bestimmt der stärkste Schritt die Komplexität.
	\[\sum_{k = 2}^n (\floor*{\frac{n}{k}} - 1) \leq \sum_{k = 2}^{n}\floor*{\frac{n}{k}} \leq \sum_{k = 1}^{n} \frac{n}{k} = n \frac{k = 1}{n} \frac{1}{k} = n\log n\]
